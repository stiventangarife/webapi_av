import { type Client, type SignableMessage, type TypedDataDefinition } from "viem";
import { type TransactionParams } from "../action/send-transaction/common";
import { type ServiceEnv } from "../utils/service-url";
import { HeadlessProvider } from "./provider";
export type CreateHeadlessCoreOpts = {
    waypointToken?: string;
    clientShard?: string;
    chainId: number;
    overrideRpcUrl?: string;
    serviceEnv?: ServiceEnv;
    wasmUrl?: string;
};
export declare class HeadlessCore {
    readonly chainId: number;
    readonly rpcUrl: string;
    readonly publicClient: Client;
    private waypointToken;
    private clientShard;
    private readonly httpUrl;
    private readonly wsUrl;
    private readonly wasmUrl;
    protected constructor(opts: CreateHeadlessCoreOpts);
    static create: (opts: CreateHeadlessCoreOpts) => HeadlessCore;
    setWaypointToken: (newToken: string) => void;
    setClientShard: (newShard: string) => void;
    isSignable: () => boolean;
    genMpc: () => Promise<string>;
    encryptClientShard: (recoveryPassword: string) => Promise<string>;
    decryptClientShard: (encryptedShard: string, recoveryPassword: string) => Promise<string>;
    backupClientShard: (recoveryPassword: string) => Promise<string>;
    getAddress: () => `0x${string}`;
    signMessage: (message: SignableMessage) => Promise<`0x${string}`>;
    signTypedData: (typedData: TypedDataDefinition) => Promise<`0x${string}`>;
    sendTransaction: (transaction: TransactionParams) => Promise<import("../action/send-transaction/common").SendTransactionResult>;
    getBackupClientShard: () => Promise<import("../action/get-backup-shard").GetBackupClientShardResult>;
    getUserProfile: () => Promise<import("../action/get-user-profile").GetUserProfileResult>;
    validateSponsorTx: (transaction: TransactionParams) => Promise<import("../action/validate-sponsor-tx").ValidateSponsorTransactionResult>;
    getProvider: () => HeadlessProvider;
}
