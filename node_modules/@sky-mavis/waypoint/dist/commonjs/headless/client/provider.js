'use strict';

var _polyfillNode_events = require('../../_polyfill-node.events-Cg_JIuru.js');
var headless_error_client = require('../error/client.js');
var rpc = require('../../rpc-BJmuIVLE.js');
var isAddressEqual = require('../../isAddressEqual-QoNFma_v.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../base-BPC6VLRS.js');
require('../../isAddress-Ajbo9xO8.js');
require('../../keccak256-DkMFbAQi.js');
require('../../utils-U8Z-__N5.js');
require('../../size-BDN9jZuU.js');

// ! Keep the same interface with internal libs
class HeadlessProvider extends _polyfillNode_events.EventEmitter {
  core;
  constructor(core) {
    super();
    this.core = core;
  }
  static fromHeadlessCore = core => {
    return new HeadlessProvider(core);
  };
  getAccounts = () => {
    try {
      const address = this.core.getAddress();
      const signable = this.core.isSignable();
      if (address && signable) {
        return [address];
      }
    } catch (error) {
      /* empty */
    }
    return [];
  };
  requestAccounts = () => {
    try {
      const address = this.core.getAddress();
      const signable = this.core.isSignable();
      if (address && signable) {
        return [address];
      }
    } catch (err) {
      if (err instanceof Error) {
        throw new rpc.UnauthorizedProviderError(err);
      }
    }
    throw new rpc.UnauthorizedProviderError(new Error("The headless core is not signable."));
  };
  personalSign = async params => {
    const [data, address] = params;
    const [currentAddress] = this.requestAccounts();
    if (!isAddressEqual.isAddressEqual(address, currentAddress)) {
      const notMatchError = new headless_error_client.HeadlessClientError({
        cause: undefined,
        code: headless_error_client.HeadlessClientErrorCode.AddressIsNotMatch,
        message: `Unable to sign message, currentAddress="${currentAddress}" is different from requestedAddress="${address}".`
      });
      throw new rpc.UnauthorizedProviderError(notMatchError);
    }
    try {
      return await this.core.signMessage({
        raw: data
      });
    } catch (err) {
      if (err instanceof Error) {
        throw new rpc.InternalRpcError(err);
      }
      const unknownErr = new headless_error_client.HeadlessClientError({
        cause: err,
        code: headless_error_client.HeadlessClientErrorCode.UnknownError,
        message: "Unable to perform personal sign."
      });
      throw new rpc.InternalRpcError(unknownErr);
    }
  };
  signTypedDataV4 = async params => {
    const [address, data] = params;
    let typedData;
    try {
      if (typeof data === "string") {
        typedData = JSON.parse(data);
      } else {
        typedData = data;
      }
    } catch (err) {
      const parseError = new headless_error_client.HeadlessClientError({
        cause: err,
        code: headless_error_client.HeadlessClientErrorCode.ParseTypedDataError,
        message: `Unable to parse typedData="${data}".`
      });
      throw new rpc.InternalRpcError(parseError);
    }
    const [currentAddress] = this.requestAccounts();
    if (!isAddressEqual.isAddressEqual(address, currentAddress)) {
      const notMatchError = new headless_error_client.HeadlessClientError({
        cause: undefined,
        code: headless_error_client.HeadlessClientErrorCode.AddressIsNotMatch,
        message: `Unable to sign typed data, currentAddress="${currentAddress}" is different from requestedAddress="${address}".`
      });
      throw new rpc.UnauthorizedProviderError(notMatchError);
    }
    try {
      return await this.core.signTypedData(typedData);
    } catch (err) {
      if (err instanceof Error) {
        throw new rpc.InternalRpcError(err);
      }
      const unknownErr = new headless_error_client.HeadlessClientError({
        cause: err,
        code: headless_error_client.HeadlessClientErrorCode.UnknownError,
        message: "Unable to sign typed data."
      });
      throw new rpc.InternalRpcError(unknownErr);
    }
  };
  request = async args => {
    const {
      params,
      method
    } = args;
    switch (method) {
      case "eth_accounts":
        {
          const result = this.getAccounts();
          return result;
        }
      case "eth_requestAccounts":
        {
          const result = await this.requestAccounts();
          return result;
        }
      case "eth_chainId":
        {
          return toBytes.toHex(this.core.chainId);
        }
      case "personal_sign":
        {
          return this.personalSign(params);
        }
      case "eth_signTypedData_v4":
        {
          return this.signTypedDataV4(params);
        }
      case "eth_sendTransaction":
        {
          try {
            const [tx] = params;
            const transaction = await this.core.sendTransaction(tx);
            return transaction.txHash;
          } catch (err) {
            if (err instanceof Error) {
              throw new rpc.InternalRpcError(err);
            }
            const unknownErr = new headless_error_client.HeadlessClientError({
              cause: err,
              code: headless_error_client.HeadlessClientErrorCode.UnknownError,
              message: "Unable to send transaction."
            });
            throw new rpc.InternalRpcError(unknownErr);
          }
        }
      default:
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return this.core.publicClient.request(args);
    }
  };
}

exports.HeadlessProvider = HeadlessProvider;
