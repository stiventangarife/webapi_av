'use strict';

var headless_action_backupShard = require('../action/backup-shard.js');
var headless_action_decryptShard = require('../action/decrypt-shard.js');
var headless_action_encryptShard = require('../action/encrypt-shard.js');
var headless_action_getAddress = require('../action/get-address.js');
var headless_action_getBackupShard = require('../action/get-backup-shard.js');
var headless_action_getUserProfile = require('../action/get-user-profile.js');
var headless_action_helpers_txTypeCheck = require('../action/helpers/tx-type-check.js');
var headless_action_keygen = require('../action/keygen.js');
var headless_action_personalSign = require('../action/personal-sign.js');
var headless_action_sendTransaction_sendPaidTx = require('../action/send-transaction/send-paid-tx.js');
var headless_action_sendTransaction_sendSponsored = require('../action/send-transaction/send-sponsored.js');
var headless_action_signTypedData = require('../action/sign-typed-data.js');
var headless_action_validateSponsorTx = require('../action/validate-sponsor-tx.js');
var headless_error_client = require('../error/client.js');
var headless_utils_serviceUrl = require('../utils/service-url.js');
var headless_utils_token = require('../utils/token.js');
var headless_wasm_cdn = require('../wasm/cdn.js');
var headless_client_provider = require('./provider.js');
var http = require('../../http-jAHgRxFF.js');
var common_chain = require('../../common/chain.js');
var isAddress = require('../../isAddress-Ajbo9xO8.js');
require('../../secp256k1-CzvWuxSM.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../error/server.js');
require('../proto/rpc.js');
require('../../file-D9-_A4DE.js');
require('../../enum-CbdizYms.js');
require('../proto/backup.js');
require('../track/track.js');
require('../../index-Pma4qYcb.js');
require('../../common/version.js');
require('../../v4-D8BIpzex.js');
require('../../sha256-DGm_MAwc.js');
require('../../size-BDN9jZuU.js');
require('../../toBytes-Dmnw03lt.js');
require('../../base-BPC6VLRS.js');
require('../utils/convertor.js');
require('../action/helpers/authenticate.js');
require('../proto/auth.js');
require('../../to-binary-B8Z0Mr_g.js');
require('../action/helpers/check-weak-bk.js');
require('../action/helpers/open-socket.js');
require('../../keccak256-DkMFbAQi.js');
require('../action/helpers/key.js');
require('../../concat-BguDurHH.js');
require('../../publicKeyToAddress-7k7v6GXz.js');
require('../action/helpers/request/abort-key.js');
require('../action/helpers/request/request.js');
require('../action/helpers/request/abort-controller.js');
require('../action/helpers/request/configurations.js');
require('../action/send-transaction/common.js');
require('../action/helpers/get-keygen-handler.js');
require('../wasm/create.js');
require('../wasm/instantiate.js');
require('../action/helpers/send-round-data.js');
require('../action/sign.js');
require('../proto/sign.js');
require('../utils/signature.js');
require('../action/helpers/get-sign-handler.js');
require('../action/helpers/trigger-sign.js');
require('../../isAddressEqual-QoNFma_v.js');
require('../../recoverAddress-C3o2uHFx.js');
require('../action/send-transaction/prepare-tx.js');
require('../../estimate-fee-per-gas-DpeR2wRz.js');
require('../../saigon-DYBomzZQ.js');
require('../../formatGwei-Sx3AlOf5.js');
require('../../getTransactionType-HIODnQRW.js');
require('../action/send-transaction/send-tx-request.js');
require('../action/send-transaction/serialize-tx.js');
require('../../slice-Ca-rzTkU.js');
require('../action/send-transaction/to-tx-hash.js');
require('../proto/message.js');
require('../../prepare-typed-data-D54m5_ZF.js');
require('../../_polyfill-node.events-Cg_JIuru.js');
require('../../rpc-BJmuIVLE.js');

// ! Keep the same interface with internal libs
class HeadlessCore {
  chainId;
  rpcUrl;
  publicClient;
  waypointToken;
  clientShard;
  httpUrl;
  wsUrl;
  wasmUrl;
  constructor(opts) {
    const {
      chainId,
      overrideRpcUrl,
      waypointToken = "",
      clientShard = "",
      serviceEnv = "prod",
      wasmUrl = headless_wasm_cdn.WASM_URL
    } = opts;
    const {
      httpUrl,
      wsUrl
    } = headless_utils_serviceUrl.getServiceUrls(serviceEnv);
    this.waypointToken = waypointToken;
    this.clientShard = clientShard;
    this.httpUrl = httpUrl;
    this.wsUrl = wsUrl;
    this.wasmUrl = wasmUrl;
    this.chainId = chainId;
    if (overrideRpcUrl) {
      this.rpcUrl = overrideRpcUrl;
      this.publicClient = http.createClient({
        transport: http.http(overrideRpcUrl)
      });
    } else {
      const rpcUrl = common_chain.VIEM_CHAIN_MAPPING[chainId]?.rpcUrls?.default?.http[0];
      if (!rpcUrl) {
        throw new headless_error_client.HeadlessClientError({
          cause: undefined,
          code: headless_error_client.HeadlessClientErrorCode.UnsupportedChainIdError,
          message: `Unsupported chain. Unable to find rpcUrl for chainId="${chainId}". Please provide an "overrideRpcUrl" parameter.`
        });
      }
      this.rpcUrl = rpcUrl;
      this.publicClient = http.createClient({
        chain: common_chain.VIEM_CHAIN_MAPPING[chainId],
        transport: http.http()
      });
    }
  }
  static create = opts => {
    return new HeadlessCore(opts);
  };
  setWaypointToken = newToken => {
    this.waypointToken = newToken;
  };
  setClientShard = newShard => {
    this.clientShard = newShard;
  };
  isSignable = () => {
    const {
      waypointToken,
      clientShard
    } = this;
    try {
      const isValidShard = isAddress.isAddress(headless_action_getAddress.getAddressFromShard(clientShard));
      const isValidToken = headless_utils_token.validateToken(waypointToken);
      return isValidShard && isValidToken;
    } catch (error) {
      /* empty */
    }
    return false;
  };
  genMpc = async () => {
    const {
      wasmUrl,
      wsUrl,
      waypointToken,
      setClientShard
    } = this;
    const clientShard = await headless_action_keygen.keygen({
      wasmUrl,
      waypointToken,
      wsUrl
    });
    // ? set client shard for future action
    setClientShard(clientShard);
    return clientShard;
  };
  encryptClientShard = recoveryPassword => {
    const {
      clientShard,
      waypointToken
    } = this;
    return headless_action_encryptShard.encryptShard({
      clientShard: clientShard,
      waypointToken,
      recoveryPassword
    });
  };
  decryptClientShard = async (encryptedShard, recoveryPassword) => {
    const {
      waypointToken,
      setClientShard
    } = this;
    const clientShard = await headless_action_decryptShard.decryptShard({
      encryptedData: encryptedShard,
      recoveryPassword,
      waypointToken
    });
    // ? set client shard for future action
    setClientShard(clientShard);
    return clientShard;
  };
  backupClientShard = recoveryPassword => {
    const {
      wsUrl,
      waypointToken,
      clientShard
    } = this;
    return headless_action_backupShard.backupShard({
      clientShard: clientShard,
      waypointToken,
      recoveryPassword,
      wsUrl
    });
  };
  getAddress = () => {
    const {
      clientShard
    } = this;
    return headless_action_getAddress.getAddressFromShard(clientShard);
  };
  signMessage = message => {
    const {
      clientShard,
      wsUrl,
      waypointToken,
      wasmUrl
    } = this;
    return headless_action_personalSign.personalSign({
      message,
      clientShard,
      waypointToken,
      wsUrl,
      wasmUrl
    });
  };
  signTypedData = typedData => {
    const {
      clientShard,
      wsUrl,
      waypointToken,
      wasmUrl
    } = this;
    return headless_action_signTypedData.signTypedData({
      typedData,
      clientShard,
      waypointToken,
      wsUrl,
      wasmUrl
    });
  };
  sendTransaction = transaction => {
    const {
      clientShard,
      waypointToken,
      wsUrl,
      wasmUrl,
      chainId,
      rpcUrl
    } = this;
    if (headless_action_helpers_txTypeCheck.isRoninGasSponsorTransaction(transaction.type)) {
      return headless_action_sendTransaction_sendSponsored.sendSponsoredTransaction({
        clientShard,
        waypointToken,
        wsUrl,
        wasmUrl,
        transaction,
        chain: {
          chainId,
          rpcUrl
        }
      });
    }
    return headless_action_sendTransaction_sendPaidTx.sendPaidTransaction({
      clientShard,
      waypointToken,
      wsUrl,
      wasmUrl,
      transaction,
      chain: {
        chainId,
        rpcUrl
      }
    });
  };
  getBackupClientShard = () => {
    const {
      httpUrl,
      waypointToken
    } = this;
    return headless_action_getBackupShard.getBackupClientShard({
      httpUrl,
      waypointToken
    });
  };
  getUserProfile = () => {
    const {
      httpUrl,
      waypointToken
    } = this;
    return headless_action_getUserProfile.getUserProfile({
      httpUrl,
      waypointToken
    });
  };
  validateSponsorTx = async transaction => {
    const {
      httpUrl,
      waypointToken,
      chainId,
      rpcUrl,
      getAddress
    } = this;
    const currentAddress = getAddress();
    return await headless_action_validateSponsorTx.validateSponsorTransaction({
      httpUrl,
      waypointToken,
      chain: {
        chainId,
        rpcUrl
      },
      transaction,
      currentAddress
    });
  };
  getProvider = () => {
    return headless_client_provider.HeadlessProvider.fromHeadlessCore(this);
  };
}

exports.HeadlessCore = HeadlessCore;
