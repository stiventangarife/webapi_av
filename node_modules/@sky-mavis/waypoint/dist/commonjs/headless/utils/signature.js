'use strict';

var secp256k1 = require('../../secp256k1-CzvWuxSM.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../../base-BPC6VLRS.js');
require('../../size-BDN9jZuU.js');

/**
 * @description Converts a signature into hex format.
 *
 * @param signature The signature to convert.
 * @returns The signature in hex format.
 *
 * @example
 * serializeSignature({
 *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
 *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
 *   yParity: 1
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */
function serializeSignature({
  r,
  s,
  to = 'hex',
  v,
  yParity
}) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1) return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;
    throw new Error('Invalid `v` or `yParity` value');
  })();
  const signature = `0x${new secp256k1.secp256k1.Signature(toBytes.hexToBigInt(r), toBytes.hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;
  if (to === 'hex') return signature;
  return toBytes.hexToBytes(signature);
}

/**
 * @description Parses a hex formatted signature into a structured signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', s: '0x...', v: 28n }
 */
function parseSignature(signatureHex) {
  const {
    r,
    s
  } = secp256k1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
  const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
  const [v, yParity] = (() => {
    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV];
    if (yParityOrV === 27) return [BigInt(yParityOrV), 0];
    if (yParityOrV === 28) return [BigInt(yParityOrV), 1];
    throw new Error('Invalid yParityOrV value');
  })();
  if (typeof v !== 'undefined') return {
    r: toBytes.numberToHex(r, {
      size: 32
    }),
    s: toBytes.numberToHex(s, {
      size: 32
    }),
    v,
    yParity
  };
  return {
    r: toBytes.numberToHex(r, {
      size: 32
    }),
    s: toBytes.numberToHex(s, {
      size: 32
    }),
    yParity
  };
}

const toEthereumSignature = sig => serializeSignature(parseSignature(sig));

exports.toEthereumSignature = toEthereumSignature;
