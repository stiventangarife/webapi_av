'use strict';

var headless_error_client = require('../../error/client.js');
var headless_action_helpers_txTypeCheck = require('../helpers/tx-type-check.js');
var headless_action_sendTransaction_common = require('./common.js');
var headless_action_sendTransaction_estimateFeePerGas = require('../../../estimate-fee-per-gas-DpeR2wRz.js');
var isAddress = require('../../../isAddress-Ajbo9xO8.js');
var http = require('../../../http-jAHgRxFF.js');
var base = require('../../../base-BPC6VLRS.js');
var recoverAddress = require('../../../recoverAddress-C3o2uHFx.js');
var concat = require('../../../concat-BguDurHH.js');
var toBytes = require('../../../toBytes-Dmnw03lt.js');
var getTransactionType = require('../../../getTransactionType-HIODnQRW.js');
var keccak256 = require('../../../keccak256-DkMFbAQi.js');
var formatGwei = require('../../../formatGwei-Sx3AlOf5.js');
require('../helpers/request/request.js');
require('../../utils/token.js');
require('../../../index-Pma4qYcb.js');
require('../helpers/request/abort-controller.js');
require('../helpers/request/configurations.js');
require('../../../saigon-DYBomzZQ.js');
require('../../../rpc-BJmuIVLE.js');
require('../../../publicKeyToAddress-7k7v6GXz.js');
require('../../../size-BDN9jZuU.js');
require('../../../sha256-DGm_MAwc.js');
require('../../../sha256-CLylCSfy.js');
require('../../../utils-U8Z-__N5.js');

/**
 * Converts numerical wei to a string representation of ether.
 *
 * - Docs: https://viem.sh/docs/utilities/formatEther
 *
 * @example
 * import { formatEther } from 'viem'
 *
 * formatEther(1000000000000000000n)
 * // '1'
 */
function formatEther(wei, unit = 'wei') {
  return formatGwei.formatUnits(wei, formatGwei.etherUnits[unit]);
}

class AccountStateConflictError extends base.BaseError {
  constructor({
    address
  }) {
    super(`State for account "${address}" is set multiple times.`, {
      name: 'AccountStateConflictError'
    });
  }
}
class StateAssignmentConflictError extends base.BaseError {
  constructor() {
    super('state and stateDiff are set on the same account.', {
      name: 'StateAssignmentConflictError'
    });
  }
}

/**
 * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */
function hashAuthorization(parameters) {
  const {
    chainId,
    contractAddress,
    nonce,
    to
  } = parameters;
  const hash = keccak256.keccak256(concat.concatHex(['0x05', getTransactionType.toRlp([toBytes.numberToHex(chainId), contractAddress, nonce ? toBytes.numberToHex(nonce) : '0x'])]));
  if (to === 'bytes') return toBytes.hexToBytes(hash);
  return hash;
}

async function recoverAuthorizationAddress(parameters) {
  const {
    authorization,
    signature
  } = parameters;
  return recoverAddress.recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

class EstimateGasExecutionError extends base.BaseError {
  constructor(cause, {
    account,
    docsPath,
    chain,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value
  }) {
    const prettyArgs = getTransactionType.prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== 'undefined' && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei.formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== 'undefined' && `${formatGwei.formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' && `${formatGwei.formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [...(cause.metaMessages ? [...cause.metaMessages, ' '] : []), 'Estimate Gas Arguments:', prettyArgs].filter(Boolean),
      name: 'EstimateGasExecutionError'
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}

function getNodeError(err, args) {
  const message = (err.details || '').toLowerCase();
  const executionRevertedError = err instanceof base.BaseError ? err.walk(e => e?.code === getTransactionType.ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof base.BaseError) return new getTransactionType.ExecutionRevertedError({
    cause: err,
    message: executionRevertedError.details
  });
  if (getTransactionType.ExecutionRevertedError.nodeMessage.test(message)) return new getTransactionType.ExecutionRevertedError({
    cause: err,
    message: err.details
  });
  if (getTransactionType.FeeCapTooHighError.nodeMessage.test(message)) return new getTransactionType.FeeCapTooHighError({
    cause: err,
    maxFeePerGas: args?.maxFeePerGas
  });
  if (getTransactionType.FeeCapTooLowError.nodeMessage.test(message)) return new getTransactionType.FeeCapTooLowError({
    cause: err,
    maxFeePerGas: args?.maxFeePerGas
  });
  if (getTransactionType.NonceTooHighError.nodeMessage.test(message)) return new getTransactionType.NonceTooHighError({
    cause: err,
    nonce: args?.nonce
  });
  if (getTransactionType.NonceTooLowError.nodeMessage.test(message)) return new getTransactionType.NonceTooLowError({
    cause: err,
    nonce: args?.nonce
  });
  if (getTransactionType.NonceMaxValueError.nodeMessage.test(message)) return new getTransactionType.NonceMaxValueError({
    cause: err,
    nonce: args?.nonce
  });
  if (getTransactionType.InsufficientFundsError.nodeMessage.test(message)) return new getTransactionType.InsufficientFundsError({
    cause: err
  });
  if (getTransactionType.IntrinsicGasTooHighError.nodeMessage.test(message)) return new getTransactionType.IntrinsicGasTooHighError({
    cause: err,
    gas: args?.gas
  });
  if (getTransactionType.IntrinsicGasTooLowError.nodeMessage.test(message)) return new getTransactionType.IntrinsicGasTooLowError({
    cause: err,
    gas: args?.gas
  });
  if (getTransactionType.TransactionTypeNotSupportedError.nodeMessage.test(message)) return new getTransactionType.TransactionTypeNotSupportedError({
    cause: err
  });
  if (getTransactionType.TipAboveFeeCapError.nodeMessage.test(message)) return new getTransactionType.TipAboveFeeCapError({
    cause: err,
    maxFeePerGas: args?.maxFeePerGas,
    maxPriorityFeePerGas: args?.maxPriorityFeePerGas
  });
  return new getTransactionType.UnknownNodeError({
    cause: err
  });
}

function getEstimateGasError(err, {
  docsPath,
  ...args
}) {
  const cause = (() => {
    const cause = getNodeError(err, args);
    if (cause instanceof getTransactionType.UnknownNodeError) return err;
    return cause;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath,
    ...args
  });
}

/**
 * @description Picks out the keys from `value` that exist in the formatter..
 */
function extract(value_, {
  format
}) {
  if (!format) return {};
  const value = {};
  function extract_(formatted) {
    const keys = Object.keys(formatted);
    for (const key of keys) {
      if (key in value_) value[key] = value_[key];
      if (formatted[key] && typeof formatted[key] === 'object' && !Array.isArray(formatted[key])) extract_(formatted[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}

const rpcTransactionType = {
  legacy: '0x0',
  eip2930: '0x1',
  eip1559: '0x2',
  eip4844: '0x3',
  eip7702: '0x4'
};
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== 'undefined') rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
  if (typeof request.accessList !== 'undefined') rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== 'undefined') rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== 'undefined') {
    if (typeof request.blobs[0] !== 'string') rpcRequest.blobs = request.blobs.map(x => toBytes.bytesToHex(x));else rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== 'undefined') rpcRequest.data = request.data;
  if (typeof request.from !== 'undefined') rpcRequest.from = request.from;
  if (typeof request.gas !== 'undefined') rpcRequest.gas = toBytes.numberToHex(request.gas);
  if (typeof request.gasPrice !== 'undefined') rpcRequest.gasPrice = toBytes.numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== 'undefined') rpcRequest.maxFeePerBlobGas = toBytes.numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== 'undefined') rpcRequest.maxFeePerGas = toBytes.numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== 'undefined') rpcRequest.maxPriorityFeePerGas = toBytes.numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== 'undefined') rpcRequest.nonce = toBytes.numberToHex(request.nonce);
  if (typeof request.to !== 'undefined') rpcRequest.to = request.to;
  if (typeof request.type !== 'undefined') rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== 'undefined') rpcRequest.value = toBytes.numberToHex(request.value);
  return rpcRequest;
}
//////////////////////////////////////////////////////////////////////////////
function formatAuthorizationList(authorizationList) {
  return authorizationList.map(authorization => ({
    address: authorization.contractAddress,
    r: authorization.r,
    s: authorization.s,
    chainId: toBytes.numberToHex(authorization.chainId),
    nonce: toBytes.numberToHex(authorization.nonce),
    ...(typeof authorization.yParity !== 'undefined' ? {
      yParity: toBytes.numberToHex(authorization.yParity)
    } : {}),
    ...(typeof authorization.v !== 'undefined' && typeof authorization.yParity === 'undefined' ? {
      v: toBytes.numberToHex(authorization.v)
    } : {})
  }));
}

/** @internal */
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0) return undefined;
  return stateMapping.reduce((acc, {
    slot,
    value
  }) => {
    if (slot.length !== 66) throw new toBytes.InvalidBytesLengthError({
      size: slot.length,
      targetSize: 66,
      type: 'hex'
    });
    if (value.length !== 66) throw new toBytes.InvalidBytesLengthError({
      size: value.length,
      targetSize: 66,
      type: 'hex'
    });
    acc[slot] = value;
    return acc;
  }, {});
}
/** @internal */
function serializeAccountStateOverride(parameters) {
  const {
    balance,
    nonce,
    state,
    stateDiff,
    code
  } = parameters;
  const rpcAccountStateOverride = {};
  if (code !== undefined) rpcAccountStateOverride.code = code;
  if (balance !== undefined) rpcAccountStateOverride.balance = toBytes.numberToHex(balance);
  if (nonce !== undefined) rpcAccountStateOverride.nonce = toBytes.numberToHex(nonce);
  if (state !== undefined) rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== undefined) {
    if (rpcAccountStateOverride.state) throw new StateAssignmentConflictError();
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
/** @internal */
function serializeStateOverride(parameters) {
  if (!parameters) return undefined;
  const rpcStateOverride = {};
  for (const {
    address,
    ...accountState
  } of parameters) {
    if (!isAddress.isAddress(address, {
      strict: false
    })) throw new isAddress.InvalidAddressError({
      address
    });
    if (rpcStateOverride[address]) throw new AccountStateConflictError({
      address: address
    });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}

function assertRequest(args) {
  const {
    account: account_,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    to
  } = args;
  const account = account_ ? http.parseAccount(account_) : undefined;
  if (account && !isAddress.isAddress(account.address)) throw new isAddress.InvalidAddressError({
    address: account.address
  });
  if (to && !isAddress.isAddress(to)) throw new isAddress.InvalidAddressError({
    address: to
  });
  if (typeof gasPrice !== 'undefined' && (typeof maxFeePerGas !== 'undefined' || typeof maxPriorityFeePerGas !== 'undefined')) throw new getTransactionType.FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > getTransactionType.maxUint256) throw new getTransactionType.FeeCapTooHighError({
    maxFeePerGas
  });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new getTransactionType.TipAboveFeeCapError({
    maxFeePerGas,
    maxPriorityFeePerGas
  });
}

/**
 * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionCount
 * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionCountParameters}
 * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionCount } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionCount = await getTransactionCount(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */
async function getTransactionCount(client, {
  address,
  blockTag = 'latest',
  blockNumber
}) {
  const count = await client.request({
    method: 'eth_getTransactionCount',
    params: [address, blockNumber ? toBytes.numberToHex(blockNumber) : blockTag]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return toBytes.hexToNumber(count);
}

/**
 * Returns the chain ID associated with the current network.
 *
 * - Docs: https://viem.sh/docs/actions/public/getChainId
 * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
 *
 * @param client - Client to use
 * @returns The current chain ID. {@link GetChainIdReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getChainId } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const chainId = await getChainId(client)
 * // 1
 */
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: 'eth_chainId'
  }, {
    dedupe: true
  });
  return toBytes.hexToNumber(chainIdHex);
}

const defaultParameters = ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type'];
/**
 * Prepares a transaction request for signing.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
 *
 * @param args - {@link PrepareTransactionRequestParameters}
 * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0xâ€¦'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */
async function prepareTransactionRequest(client, args) {
  const {
    account: account_ = client.account,
    blobs,
    chain,
    gas,
    kzg,
    nonce,
    nonceManager,
    parameters = defaultParameters,
    type
  } = args;
  const account = account_ ? http.parseAccount(account_) : undefined;
  const request = {
    ...args,
    ...(account ? {
      from: account?.address
    } : {})
  };
  let block;
  async function getBlock() {
    if (block) return block;
    block = await headless_action_sendTransaction_estimateFeePerGas.getAction(client, headless_action_sendTransaction_estimateFeePerGas.getBlock, 'getBlock')({
      blockTag: 'latest'
    });
    return block;
  }
  let chainId;
  async function getChainId$1() {
    if (chainId) return chainId;
    if (chain) return chain.id;
    if (typeof args.chainId !== 'undefined') return args.chainId;
    const chainId_ = await headless_action_sendTransaction_estimateFeePerGas.getAction(client, getChainId, 'getChainId')({});
    chainId = chainId_;
    return chainId;
  }
  if ((parameters.includes('blobVersionedHashes') || parameters.includes('sidecars')) && blobs && kzg) {
    const commitments = getTransactionType.blobsToCommitments({
      blobs,
      kzg
    });
    if (parameters.includes('blobVersionedHashes')) {
      const versionedHashes = getTransactionType.commitmentsToVersionedHashes({
        commitments,
        to: 'hex'
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes('sidecars')) {
      const proofs = getTransactionType.blobsToProofs({
        blobs,
        commitments,
        kzg
      });
      const sidecars = getTransactionType.toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: 'hex'
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes('chainId')) request.chainId = await getChainId$1();
  if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {
    if (nonceManager) {
      const chainId = await getChainId$1();
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId,
        client
      });
    } else {
      request.nonce = await headless_action_sendTransaction_estimateFeePerGas.getAction(client, getTransactionCount, 'getTransactionCount')({
        address: account.address,
        blockTag: 'pending'
      });
    }
  }
  if ((parameters.includes('fees') || parameters.includes('type')) && typeof type === 'undefined') {
    try {
      request.type = getTransactionType.getTransactionType(request);
    } catch {
      // infer type from block
      const block = await getBlock();
      request.type = typeof block?.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy';
    }
  }
  if (parameters.includes('fees')) {
    // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.
    if (request.type !== 'legacy' && request.type !== 'eip2930') {
      // EIP-1559 fees
      if (typeof request.maxFeePerGas === 'undefined' || typeof request.maxPriorityFeePerGas === 'undefined') {
        const block = await getBlock();
        const {
          maxFeePerGas,
          maxPriorityFeePerGas
        } = await headless_action_sendTransaction_estimateFeePerGas.internal_estimateFeesPerGas(client, {
          block: block,
          chain,
          request: request
        });
        if (typeof args.maxPriorityFeePerGas === 'undefined' && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas) throw new headless_action_sendTransaction_estimateFeePerGas.MaxFeePerGasTooLowError({
          maxPriorityFeePerGas
        });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      // Legacy fees
      if (typeof args.maxFeePerGas !== 'undefined' || typeof args.maxPriorityFeePerGas !== 'undefined') throw new headless_action_sendTransaction_estimateFeePerGas.Eip1559FeesNotSupportedError();
      const block = await getBlock();
      const {
        gasPrice: gasPrice_
      } = await headless_action_sendTransaction_estimateFeePerGas.internal_estimateFeesPerGas(client, {
        block: block,
        chain,
        request: request,
        type: 'legacy'
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes('gas') && typeof gas === 'undefined') request.gas = await headless_action_sendTransaction_estimateFeePerGas.getAction(client, estimateGas, 'estimateGas')({
    ...request,
    account: account ? {
      address: account.address,
      type: 'json-rpc'
    } : undefined
  });
  assertRequest(request);
  delete request.parameters;
  return request;
}

/**
 * Returns the balance of an address in wei.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBalance
 * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
 *
 * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).
 *
 * ```ts
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   blockTag: 'safe'
 * })
 * const balanceAsEther = formatEther(balance)
 * // "6.942"
 * ```
 *
 * @param client - Client to use
 * @param parameters - {@link GetBalanceParameters}
 * @returns The balance of the address in wei. {@link GetBalanceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBalance } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 * // 10000000000000000000000n (wei)
 */
async function getBalance(client, {
  address,
  blockNumber,
  blockTag = 'latest'
}) {
  const blockNumberHex = blockNumber ? toBytes.numberToHex(blockNumber) : undefined;
  const balance = await client.request({
    method: 'eth_getBalance',
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

/**
 * Estimates the gas necessary to complete a transaction without submitting it to the network.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateGas
 * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateGasParameters}
 * @returns The gas estimate (in wei). {@link EstimateGasReturnType}
 *
 * @example
 * import { createPublicClient, http, parseEther } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateGas } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasEstimate = await estimateGas(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: parseEther('1'),
 * })
 */
async function estimateGas(client, args) {
  const account_ = args.account ?? client.account;
  const account = account_ ? http.parseAccount(account_) : undefined;
  try {
    const {
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      blockNumber,
      blockTag,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      value,
      stateOverride,
      ...rest
    } = await prepareTransactionRequest(client, {
      ...args,
      parameters:
      // Some RPC Providers do not compute versioned hashes from blobs. We will need
      // to compute them.
      account?.type === 'local' ? undefined : ['blobVersionedHashes']
    });
    const blockNumberHex = blockNumber ? toBytes.numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      // If `to` exists on the parameters, use that.
      if (rest.to) return rest.to;
      // If no `to` exists, and we are sending a EIP-7702 transaction, use the
      // address of the first authorization in the list.
      if (authorizationList && authorizationList.length > 0) return await recoverAuthorizationAddress({
        authorization: authorizationList[0]
      }).catch(() => {
        throw new base.BaseError('`to` is required. Could not infer from `authorizationList`');
      });
      // Otherwise, we are sending a deployment transaction.
      return undefined;
    })();
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, {
        format: chainFormat
      }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    function estimateGas_rpc(parameters) {
      const {
        block,
        request,
        rpcStateOverride
      } = parameters;
      return client.request({
        method: 'eth_estimateGas',
        params: rpcStateOverride ? [request, block ?? 'latest', rpcStateOverride] : block ? [request, block] : [request]
      });
    }
    let estimate = BigInt(await estimateGas_rpc({
      block,
      request,
      rpcStateOverride
    }));
    // TODO(7702): Remove this once https://github.com/ethereum/execution-apis/issues/561 is resolved.
    //       Authorization list schema is not implemented on JSON-RPC spec yet, so we need to
    //       manually estimate the gas.
    if (authorizationList) {
      const value = await getBalance(client, {
        address: request.from
      });
      const estimates = await Promise.all(authorizationList.map(async authorization => {
        const {
          contractAddress
        } = authorization;
        const estimate = await estimateGas_rpc({
          block,
          request: {
            authorizationList: undefined,
            data,
            from: account?.address,
            to: contractAddress,
            value: toBytes.numberToHex(value)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

const DEFAULT_VALUE = "0x0";
const DEFAULT_DATA = "0x";
const GAS_LIMIT_BUFFER_MULTIPLIER = 2n;
const EXPIRED_TIME_PLACEHOLDER = "0x5208";
function validateTransactionType(type) {
  if (!headless_action_helpers_txTypeCheck.isSupportedTransaction(type)) throw new headless_error_client.HeadlessClientError({
    cause: undefined,
    code: headless_error_client.HeadlessClientErrorCode.UnsupportedTransactionTypeError,
    message: `Transaction type "${type}" is not supported. Supported types: legacy (0x0), EIP1559 (0x2), sponsored (0x64).`
  });
  return type;
}
function validateToAddress(to) {
  if (!to || !isAddress.isAddress(to)) throw new headless_error_client.HeadlessClientError({
    cause: undefined,
    code: headless_error_client.HeadlessClientErrorCode.UnsupportedTransactionTypeError,
    message: `Invalid 'to' address: ${to}.`
  });
  return to;
}
function validateFromAddress(from) {
  if (!from || !isAddress.isAddress(from)) throw new headless_error_client.HeadlessClientError({
    cause: undefined,
    code: headless_error_client.HeadlessClientErrorCode.PrepareTransactionError,
    message: `Invalid 'from' address: ${from}.`
  });
  return from;
}
async function estimateGasLimit(client, params) {
  try {
    const {
      to,
      from,
      value,
      data,
      gas
    } = params;
    if (gas) return gas;
    const baseGasLimit = await estimateGas(client, {
      to,
      account: from,
      value: toBytes.hexToBigInt(value),
      data
    });
    return toBytes.numberToHex(baseGasLimit * GAS_LIMIT_BUFFER_MULTIPLIER);
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.PrepareTransactionError,
      message: "Failed to estimate gas limit. This could be due to network issues or invalid transaction parameters."
    });
  }
}
async function getNonceFromNetwork(client, params) {
  try {
    const {
      from,
      nonce
    } = params;
    if (nonce) return nonce;
    const count = await getTransactionCount(client, {
      address: from,
      blockTag: "pending"
    });
    return toBytes.numberToHex(count);
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.PrepareTransactionError,
      message: "Failed to get transaction nonce. This could be due to network issues or RPC problems."
    });
  }
}
const toTransactionInServerFormat = async params => {
  const {
    chain: {
      chainId,
      rpcUrl
    },
    currentAddress,
    transaction
  } = params;
  const {
    value = DEFAULT_VALUE,
    data = DEFAULT_DATA,
    type: rawType = headless_action_sendTransaction_common.SupportedTransaction.EIP1559,
    from: rawFrom = currentAddress,
    to: rawTo,
    gasPrice: rawGasPrice,
    nonce: rawNonce,
    input,
    gas
  } = transaction;
  const type = validateTransactionType(rawType);
  const to = validateToAddress(rawTo);
  const from = validateFromAddress(rawFrom);
  const client = http.createClient({
    transport: http.http(rpcUrl)
  });
  const transactionData = input ?? data;
  try {
    const [nonce, feesPerGas, gasLimit] = await Promise.all([getNonceFromNetwork(client, {
      from,
      nonce: rawNonce
    }), headless_action_sendTransaction_estimateFeePerGas.estimateFeesPerGas(client, {
      type,
      chainId,
      gasPrice: rawGasPrice
    }), estimateGasLimit(client, {
      to,
      from,
      value,
      gas,
      data: transactionData
    })]);
    const {
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas
    } = feesPerGas;
    const formattedTransaction = {
      type,
      from,
      to,
      value,
      nonce,
      gasPrice,
      input: transactionData,
      chainId: toBytes.numberToHex(chainId),
      gas: gasLimit,
      maxFeePerGas,
      maxPriorityFeePerGas,
      r: DEFAULT_VALUE,
      v: DEFAULT_VALUE,
      s: DEFAULT_VALUE,
      payerS: headless_action_sendTransaction_common.PAYER_INFO.s,
      payerR: headless_action_sendTransaction_common.PAYER_INFO.r,
      payerV: headless_action_sendTransaction_common.PAYER_INFO.v,
      expiredTime: EXPIRED_TIME_PLACEHOLDER
    };
    return formattedTransaction;
  } catch (error) {
    if (error instanceof headless_error_client.HeadlessClientError) {
      throw error;
    }
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.PrepareTransactionError,
      message: "Failed to prepare transaction for server format."
    });
  }
};

exports.DEFAULT_DATA = DEFAULT_DATA;
exports.DEFAULT_VALUE = DEFAULT_VALUE;
exports.EXPIRED_TIME_PLACEHOLDER = EXPIRED_TIME_PLACEHOLDER;
exports.GAS_LIMIT_BUFFER_MULTIPLIER = GAS_LIMIT_BUFFER_MULTIPLIER;
exports.estimateGasLimit = estimateGasLimit;
exports.getNonceFromNetwork = getNonceFromNetwork;
exports.toTransactionInServerFormat = toTransactionInServerFormat;
exports.validateFromAddress = validateFromAddress;
exports.validateToAddress = validateToAddress;
exports.validateTransactionType = validateTransactionType;
