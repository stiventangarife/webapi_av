'use strict';

var headless_error_client = require('../../error/client.js');
var headless_error_server = require('../../error/server.js');
var headless_proto_message = require('../../proto/message.js');
var headless_proto_rpc = require('../../proto/rpc.js');
var headless_track_track = require('../../track/track.js');
var headless_action_getAddress = require('../get-address.js');
var headless_action_helpers_authenticate = require('../helpers/authenticate.js');
var headless_action_helpers_getSignHandler = require('../helpers/get-sign-handler.js');
var headless_action_helpers_openSocket = require('../helpers/open-socket.js');
var headless_action_helpers_sendRoundData = require('../helpers/send-round-data.js');
var headless_action_helpers_triggerSign = require('../helpers/trigger-sign.js');
var headless_action_sendTransaction_prepareTx = require('./prepare-tx.js');
var headless_action_sendTransaction_sendTxRequest = require('./send-tx-request.js');
var headless_action_sendTransaction_toTxHash = require('./to-tx-hash.js');
var file = require('../../../file-D9-_A4DE.js');
require('../../../enum-CbdizYms.js');
require('../../../index-Pma4qYcb.js');
require('../../../common/version.js');
require('../../utils/service-url.js');
require('../../../v4-D8BIpzex.js');
require('../../../sha256-DGm_MAwc.js');
require('../../../sha256-CLylCSfy.js');
require('../../../utils-U8Z-__N5.js');
require('../../../size-BDN9jZuU.js');
require('../../../toBytes-Dmnw03lt.js');
require('../../../base-BPC6VLRS.js');
require('../../../secp256k1-CzvWuxSM.js');
require('../../utils/convertor.js');
require('../../../publicKeyToAddress-7k7v6GXz.js');
require('../../../isAddress-Ajbo9xO8.js');
require('../../../keccak256-DkMFbAQi.js');
require('../../proto/auth.js');
require('../../utils/token.js');
require('../../../to-binary-B8Z0Mr_g.js');
require('../../wasm/create.js');
require('../../wasm/instantiate.js');
require('../helpers/tx-type-check.js');
require('./common.js');
require('../../../estimate-fee-per-gas-DpeR2wRz.js');
require('../helpers/request/request.js');
require('../helpers/request/abort-controller.js');
require('../helpers/request/configurations.js');
require('../../../saigon-DYBomzZQ.js');
require('../../../formatGwei-Sx3AlOf5.js');
require('../../../http-jAHgRxFF.js');
require('../../../rpc-BJmuIVLE.js');
require('../../../recoverAddress-C3o2uHFx.js');
require('../../../concat-BguDurHH.js');
require('../../../getTransactionType-HIODnQRW.js');
require('../../proto/sign.js');

const toSerializedSponsoredTransaction = frame => {
  if (frame.type !== headless_proto_rpc.Type.DATA) throw headless_error_server.decodeServerError(frame);
  try {
    const message = file.fromBinary(headless_proto_message.MessageSchema, frame.data);
    return message.data;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      code: headless_error_client.HeadlessClientErrorCode.SendTransactionError,
      message: `Unable to decode frame data received from the server. The data should be in a serialized transaction schema.`,
      cause: error
    });
  }
};
const _sendSponsoredTransaction = async params => {
  const {
    waypointToken,
    clientShard,
    chain,
    transaction,
    wasmUrl,
    wsUrl
  } = params;
  const address = headless_action_getAddress.getAddressFromShard(clientShard);
  const txInServerFormat = await headless_action_sendTransaction_prepareTx.toTransactionInServerFormat({
    chain,
    transaction,
    currentAddress: address
  });
  console.debug("🔏 SEND TX: start");
  const signHandler = await headless_action_helpers_getSignHandler.wasmGetSignHandler(wasmUrl);
  console.debug("🔏 SEND TX: wasm is ready");
  const socket = await headless_action_helpers_openSocket.openSocket(`${wsUrl}/v1/public/ws/send`);
  const {
    waitAndDequeue
  } = headless_action_helpers_openSocket.createFrameQueue(socket);
  console.debug("🔏 SEND TX: socket is ready");
  try {
    headless_action_helpers_authenticate.sendAuthenticate(socket, waypointToken);
    const authFrame = await waitAndDequeue();
    const authData = headless_action_helpers_authenticate.decodeAuthenticateData(authFrame);
    console.debug("🔏 SEND TX: authenticated", authData.uuid);
    headless_action_sendTransaction_sendTxRequest.sendTransactionRequest(socket, txInServerFormat, chain);
    console.debug("🔏 SEND TX: trigger socket sign");
    const serializedTxFrame = await waitAndDequeue();
    const serializedTx = toSerializedSponsoredTransaction(serializedTxFrame);
    const signResultPromise = headless_action_helpers_triggerSign.wasmTriggerSign(signHandler, serializedTx, clientShard);
    console.debug("🔏 SEND TX: trigger wasm sign");
    const sessionFrame = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeSessionAndTransferToWasm(signHandler, sessionFrame);
    const socketR1 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR1);
    console.debug("🔏 SEND TX: socket - round 1");
    const wasmR1 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR1);
    console.debug("🔏 SEND TX: wasm - round 1");
    const socketR2 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR2);
    console.debug("🔏 SEND TX: socket - round 2");
    const wasmR2 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR2);
    console.debug("🔏 SEND TX: wasm - round 2");
    const socketR3 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR3);
    console.debug("🔏 SEND TX: socket - round 3");
    const sessionR2Frame = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeSessionAndTransferToWasm(signHandler, sessionR2Frame);
    const socketR4 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR4);
    console.debug("🔏 SEND TX: socket - round 4");
    const wasmR3 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR3);
    console.debug("🔏 SEND TX: wasm - round 3");
    const socketR5 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR5);
    console.debug("🔏 SEND TX: socket - round 5");
    const sendTransactionResponseFrame = await waitAndDequeue();
    const txHash = headless_action_sendTransaction_toTxHash.toTxHash(sendTransactionResponseFrame);
    const doneFrame = await waitAndDequeue();
    if (doneFrame.type !== headless_proto_rpc.Type.DONE) throw headless_error_server.decodeServerError(doneFrame);
    const signature = await signResultPromise;
    console.debug("🔏 SEND TX: done");
    return {
      txHash: txHash,
      signature
    };
  } finally {
    socket.close();
  }
};
const sendSponsoredTransaction = async params => {
  const {
    chain,
    transaction,
    wasmUrl,
    waypointToken,
    wsUrl
  } = params;
  const tracker = headless_track_track.createTracker({
    event: headless_track_track.HeadlessEventName.sendSponsoredTransaction,
    waypointToken,
    productionFactor: wsUrl,
    wasmUrl
  });
  try {
    const result = await _sendSponsoredTransaction(params);
    const {
      txHash
    } = result;
    tracker.trackOk({
      request: {
        transaction,
        chain
      },
      response: {
        txHash
      }
    });
    return result;
  } catch (error) {
    tracker.trackError(error);
    throw error;
  }
};

exports.sendSponsoredTransaction = sendSponsoredTransaction;
exports.toSerializedSponsoredTransaction = toSerializedSponsoredTransaction;
