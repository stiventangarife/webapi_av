'use strict';

var headless_error_client = require('../error/client.js');
var headless_track_track = require('../track/track.js');
var headless_action_getAddress = require('./get-address.js');
var headless_action_sign = require('./sign.js');
var concat = require('../../concat-BguDurHH.js');
var size = require('../../size-BDN9jZuU.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
var isAddress = require('../../isAddress-Ajbo9xO8.js');
var isAddressEqual = require('../../isAddressEqual-QoNFma_v.js');
var keccak256 = require('../../keccak256-DkMFbAQi.js');
var recoverAddress = require('../../recoverAddress-C3o2uHFx.js');
require('../../index-Pma4qYcb.js');
require('../../common/version.js');
require('../error/server.js');
require('../proto/rpc.js');
require('../../file-D9-_A4DE.js');
require('../../enum-CbdizYms.js');
require('../utils/service-url.js');
require('../../v4-D8BIpzex.js');
require('../../sha256-DGm_MAwc.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../../base-BPC6VLRS.js');
require('../../secp256k1-CzvWuxSM.js');
require('../utils/convertor.js');
require('../../publicKeyToAddress-7k7v6GXz.js');
require('../proto/sign.js');
require('../utils/signature.js');
require('./helpers/authenticate.js');
require('../proto/auth.js');
require('../utils/token.js');
require('../../to-binary-B8Z0Mr_g.js');
require('./helpers/get-sign-handler.js');
require('../wasm/create.js');
require('../wasm/instantiate.js');
require('./helpers/open-socket.js');
require('./helpers/send-round-data.js');
require('./helpers/trigger-sign.js');

const presignMessagePrefix = '\x19Ethereum Signed Message:\n';

function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === 'string') return toBytes.stringToHex(message_);
    if (typeof message_.raw === 'string') return message_.raw;
    return toBytes.bytesToHex(message_.raw);
  })();
  const prefix = toBytes.stringToHex(`${presignMessagePrefix}${size.size(message)}`);
  return concat.concat([prefix, message]);
}

function hashMessage(message, to_) {
  return keccak256.keccak256(toPrefixedMessage(message), to_);
}

async function recoverMessageAddress({
  message,
  signature
}) {
  return recoverAddress.recoverAddress({
    hash: hashMessage(message),
    signature
  });
}

/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}
 *
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */
async function verifyMessage({
  address,
  message,
  signature
}) {
  return isAddressEqual.isAddressEqual(isAddress.getAddress(address), await recoverMessageAddress({
    message,
    signature
  }));
}

const personalSign = async params => {
  const tracker = headless_track_track.createTracker({
    event: headless_track_track.HeadlessEventName.personalSign,
    waypointToken: params.waypointToken,
    productionFactor: params.wsUrl,
    wasmUrl: params.wasmUrl
  });
  try {
    const {
      message,
      ...restParams
    } = params;
    const address = headless_action_getAddress.getAddressFromShard(params.clientShard);
    const prefixedMessage = toPrefixedMessage(message);
    const signature = await headless_action_sign._sign({
      ...restParams,
      rawMessage: prefixedMessage
    });
    const isValid = await verifyMessage({
      address: address,
      message,
      signature
    });
    if (!isValid) throw new headless_error_client.HeadlessClientError({
      cause: undefined,
      code: headless_error_client.HeadlessClientErrorCode.InvalidSignatureError,
      message: `Unable to verify the signature="${signature}" with the given address="${address}".`
    });
    tracker.trackOk({
      request: {
        message
      }
    });
    return signature;
  } catch (error) {
    tracker.trackError(error);
    throw error;
  }
};

exports.personalSign = personalSign;
