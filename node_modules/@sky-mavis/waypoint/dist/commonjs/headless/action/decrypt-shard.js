'use strict';

var headless_error_client = require('../error/client.js');
var headless_track_track = require('../track/track.js');
var headless_utils_convertor = require('../utils/convertor.js');
var headless_action_encryptShard = require('./encrypt-shard.js');
var headless_action_helpers_checkWeakBk = require('./helpers/check-weak-bk.js');
var headless_action_helpers_key = require('./helpers/key.js');
var concat = require('../../concat-BguDurHH.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../index-Pma4qYcb.js');
require('../../common/version.js');
require('../error/server.js');
require('../proto/rpc.js');
require('../../file-D9-_A4DE.js');
require('../../enum-CbdizYms.js');
require('../utils/service-url.js');
require('../../v4-D8BIpzex.js');
require('../../sha256-DGm_MAwc.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../../size-BDN9jZuU.js');
require('../../base-BPC6VLRS.js');

/**
 * Decodes a byte array into a UTF-8 string.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring
 *
 * @param bytes Byte array to decode.
 * @param opts Options.
 * @returns String value.
 *
 * @example
 * import { bytesToString } from 'viem'
 * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // 'Hello world'
 */
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== 'undefined') {
    toBytes.assertSize(bytes, {
      size: opts.size
    });
    bytes = toBytes.trim(bytes, {
      dir: 'right'
    });
  }
  return new TextDecoder().decode(bytes);
}

const unpackEncryptedContent = packedContent => {
  const l2InBytes = headless_utils_convertor.base64ToBytes(packedContent);
  const l1InBase64 = bytesToString(l2InBytes);
  const content = headless_utils_convertor.base64ToBytes(l1InBase64);
  const ivSize = content[0] ?? headless_action_encryptShard.IV_LENGTH_BYTE; // * 1st byte: iv size
  const authTagSize = content[1] ?? headless_action_encryptShard.TAG_LENGTH_BYTE; // * 2nd byte: auth tag size
  const iv = content.slice(2, 2 + ivSize);
  const cipherText = content.slice(2 + ivSize, content.length - authTagSize);
  const authTag = content.slice(content.length - authTagSize);
  return {
    iv,
    authTag,
    cipherText
  };
};
const getV1PackedContent = encryptedData => {
  const parts = encryptedData.split(".");
  const v1Content = parts[0];
  if (!v1Content) {
    throw "Encrypted content is empty.";
  }
  return v1Content;
};
const decryptShard = async params => {
  const {
    waypointToken,
    recoveryPassword,
    encryptedData
  } = params;
  const tracker = headless_track_track.createTracker({
    event: headless_track_track.HeadlessEventName.decryptShard,
    waypointToken,
    // * decrypt function is not environment dependent - always track as production
    productionFactor: true
  });
  try {
    const v1PackedContent = getV1PackedContent(encryptedData);
    const {
      authTag,
      cipherText,
      iv
    } = unpackEncryptedContent(v1PackedContent);
    const key = await headless_action_helpers_key.deriveKey(waypointToken, recoveryPassword);
    const shardInBytes = await crypto.subtle.decrypt({
      name: "AES-GCM",
      iv
    }, key, concat.concatBytes([cipherText, authTag]));
    const shardInBase64 = bytesToString(new Uint8Array(shardInBytes));
    tracker.trackOk({
      request: {
        isWeakBk: headless_action_helpers_checkWeakBk.checkWeakBk(recoveryPassword)
      }
    });
    return shardInBase64;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.DecryptClientShardError,
      message: "Unable to decrypt the client shard. It is probably the wrong recovery password."
    });
  }
};

exports.decryptShard = decryptShard;
