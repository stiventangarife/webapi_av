'use strict';

var secp256k1 = require('../../secp256k1-CzvWuxSM.js');
var headless_error_client = require('../error/client.js');
var headless_error_server = require('../error/server.js');
var headless_proto_backup = require('../proto/backup.js');
var headless_proto_rpc = require('../proto/rpc.js');
var headless_track_track = require('../track/track.js');
var headless_utils_convertor = require('../utils/convertor.js');
var headless_action_encryptShard = require('./encrypt-shard.js');
var headless_action_getAddress = require('./get-address.js');
var headless_action_helpers_authenticate = require('./helpers/authenticate.js');
var headless_action_helpers_checkWeakBk = require('./helpers/check-weak-bk.js');
var headless_action_helpers_openSocket = require('./helpers/open-socket.js');
var toBinary = require('../../to-binary-B8Z0Mr_g.js');
var file = require('../../file-D9-_A4DE.js');
var keccak256 = require('../../keccak256-DkMFbAQi.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../../enum-CbdizYms.js');
require('../../index-Pma4qYcb.js');
require('../../common/version.js');
require('../utils/service-url.js');
require('../../v4-D8BIpzex.js');
require('../../sha256-DGm_MAwc.js');
require('../../size-BDN9jZuU.js');
require('./helpers/key.js');
require('../../concat-BguDurHH.js');
require('../../base-BPC6VLRS.js');
require('../../publicKeyToAddress-7k7v6GXz.js');
require('../../isAddress-Ajbo9xO8.js');
require('../proto/auth.js');
require('../utils/token.js');

const sendBackupRequest = socket => {
  const backupRequest = file.create(headless_proto_backup.BackupRequestSchema, {
    type: headless_proto_backup.BackupType.CHALLENGE
  });
  const frame = file.create(headless_proto_rpc.FrameSchema, {
    type: headless_proto_rpc.Type.DATA,
    data: toBinary.toBinary(headless_proto_backup.BackupRequestSchema, backupRequest)
  });
  socket.send(toBinary.toBinary(headless_proto_rpc.FrameSchema, frame));
};
const sendEncryptedShard = (socket, encryptedShard, signature) => {
  const createBackupParams = file.create(headless_proto_backup.CreateBackupParamsSchema, {
    encryptedKey: encryptedShard,
    signResult: headless_utils_convertor.bytesToBase64(signature)
  });
  const backupRequest = file.create(headless_proto_backup.BackupRequestSchema, {
    type: headless_proto_backup.BackupType.CREATE,
    params: toBinary.toBinary(headless_proto_backup.CreateBackupParamsSchema, createBackupParams)
  });
  const frame = file.create(headless_proto_rpc.FrameSchema, {
    type: headless_proto_rpc.Type.DATA,
    data: toBinary.toBinary(headless_proto_backup.BackupRequestSchema, backupRequest)
  });
  socket.send(toBinary.toBinary(headless_proto_rpc.FrameSchema, frame));
};
const decodeSignChallenge = challengeResponseFrame => {
  if (challengeResponseFrame.type !== headless_proto_rpc.Type.DATA) throw headless_error_server.decodeServerError(challengeResponseFrame);
  try {
    const challengeResponse = file.fromBinary(headless_proto_backup.BackupResponseSchema, challengeResponseFrame.data);
    const {
      challengeString
    } = file.fromBinary(headless_proto_backup.ChallengeInfoSchema, challengeResponse.result);
    const signChallenge = keccak256.keccak256(toBytes.stringToBytes(challengeString), "bytes");
    return signChallenge;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      code: headless_error_client.HeadlessClientErrorCode.BackupClientShardError,
      message: `Unable to decode frame data received from the server. The data should be in a sign challenge schema.`,
      cause: error
    });
  }
};
const signChallenge = (signChallenge, secret) => {
  try {
    const signature = secp256k1.secp256k1.sign(signChallenge, secret);
    return signature.toCompactRawBytes();
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      code: headless_error_client.HeadlessClientErrorCode.BackupClientShardError,
      message: `Unable to sign the challenge with the client shard.`,
      cause: error
    });
  }
};
const _backupShard = async params => {
  const {
    waypointToken,
    clientShard,
    recoveryPassword,
    wsUrl
  } = params;
  const secret = headless_action_getAddress.getSecretFromShard(clientShard);
  const encryptedShard = await headless_action_encryptShard.encryptShard({
    clientShard,
    recoveryPassword,
    waypointToken
  });
  console.debug("ðŸ” BACKUP: start");
  const socket = await headless_action_helpers_openSocket.openSocket(`${wsUrl}/v1/public/ws/backup/keys`);
  const {
    waitAndDequeue
  } = headless_action_helpers_openSocket.createFrameQueue(socket);
  console.debug("ðŸ” BACKUP: socket is ready");
  try {
    headless_action_helpers_authenticate.sendAuthenticate(socket, waypointToken);
    const authFrame = await waitAndDequeue();
    const authData = headless_action_helpers_authenticate.decodeAuthenticateData(authFrame);
    console.debug("ðŸ” BACKUP: authenticated", authData.uuid);
    sendBackupRequest(socket);
    const challengeFrame = await waitAndDequeue();
    const challenge = decodeSignChallenge(challengeFrame);
    const signature = signChallenge(challenge, secret);
    sendEncryptedShard(socket, encryptedShard, signature);
    const doneFrame = await waitAndDequeue();
    if (doneFrame.type !== headless_proto_rpc.Type.DONE) throw headless_error_server.decodeServerError(doneFrame);
    console.debug("ðŸ” BACKUP: done");
    return encryptedShard;
  } finally {
    socket.close();
  }
};
const backupShard = async params => {
  const {
    recoveryPassword,
    waypointToken,
    wsUrl
  } = params;
  const tracker = headless_track_track.createTracker({
    event: headless_track_track.HeadlessEventName.backupShard,
    waypointToken,
    productionFactor: wsUrl
  });
  try {
    const result = await _backupShard(params);
    tracker.trackOk({
      request: {
        isWeakBk: headless_action_helpers_checkWeakBk.checkWeakBk(recoveryPassword)
      }
    });
    return result;
  } catch (error) {
    tracker.trackError(error);
    throw error;
  }
};

exports.backupShard = backupShard;
