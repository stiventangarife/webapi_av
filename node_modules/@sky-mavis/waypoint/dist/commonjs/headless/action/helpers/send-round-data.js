'use strict';

var headless_error_client = require('../../error/client.js');
var headless_error_server = require('../../error/server.js');
var headless_proto_rpc = require('../../proto/rpc.js');
var headless_utils_convertor = require('../../utils/convertor.js');
var file = require('../../../file-D9-_A4DE.js');
var toBinary = require('../../../to-binary-B8Z0Mr_g.js');
require('../../../enum-CbdizYms.js');
require('../../../toBytes-Dmnw03lt.js');
require('../../../base-BPC6VLRS.js');
require('../../../size-BDN9jZuU.js');

const wasmGetProtocolData = async signHandler => {
  try {
    const wasmResultInBytes = await signHandler.rx();
    const wasmResult = headless_utils_convertor.bytesToJson(wasmResultInBytes);
    const {
      kind,
      data
    } = wasmResult ?? {};
    if (kind === "mpc_protocol" && data) {
      return data;
    }
    throw "Protocol data received from WASM is not valid.";
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.WasmGetProtocolResultError,
      message: `Unable to receive the protocol round data from WASM process.`
    });
  }
};
const decodeProtocolDataAndTransferToWasm = (signHandler, frame) => {
  if (frame.type !== headless_proto_rpc.Type.DATA) throw headless_error_server.decodeServerError(frame);
  try {
    const txParams = {
      kind: "mpc_protocol",
      data: headless_utils_convertor.bytesToBase64(frame.data)
    };
    signHandler.tx(headless_utils_convertor.jsonToBytes(txParams));
    return;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.WasmReceiveSocketDataError,
      message: `Unable to transfer the protocol data from the socket to WASM.`
    });
  }
};
const decodeSessionAndTransferToWasm = (signHandler, frame) => {
  if (frame.type !== headless_proto_rpc.Type.DATA) throw headless_error_server.decodeServerError(frame);
  try {
    const session = file.fromBinary(headless_proto_rpc.SessionSchema, frame.data);
    const txParams = {
      kind: "mpc_protocol",
      data: {
        sessionID: session.sessionId
      }
    };
    signHandler.tx(headless_utils_convertor.jsonToBytes(txParams));
    return;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.WasmReceiveSocketDataError,
      message: `Unable to transfer the session data from the socket to WASM.`
    });
  }
};
const sendProtocolData = (socket, base64Data) => {
  const frame = file.create(headless_proto_rpc.FrameSchema, {
    type: headless_proto_rpc.Type.DATA,
    data: headless_utils_convertor.base64ToBytes(base64Data)
  });
  socket.send(toBinary.toBinary(headless_proto_rpc.FrameSchema, frame));
};

exports.decodeProtocolDataAndTransferToWasm = decodeProtocolDataAndTransferToWasm;
exports.decodeSessionAndTransferToWasm = decodeSessionAndTransferToWasm;
exports.sendProtocolData = sendProtocolData;
exports.wasmGetProtocolData = wasmGetProtocolData;
