'use strict';

var headless_error_client = require('../error/client.js');
var headless_utils_convertor = require('../utils/convertor.js');
var headless_action_helpers_key = require('./helpers/key.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
var concat = require('../../concat-BguDurHH.js');
require('../../index-Pma4qYcb.js');
require('../../base-BPC6VLRS.js');
require('../../size-BDN9jZuU.js');

const packEncryptedContent = (cipherText, iv, authTag) => {
  // * format: [nonceSize][authTagSize][nonce][authTag][cipherText]
  const content = concat.concatBytes([toBytes.numberToBytes(iv.length), toBytes.numberToBytes(authTag.length), iv, cipherText, authTag]);
  // * 2 layer base64 encoding
  const l1InBase64 = headless_utils_convertor.bytesToBase64(content);
  const l2InBytes = toBytes.stringToBytes(l1InBase64);
  const l2InBase64 = headless_utils_convertor.bytesToBase64(l2InBytes);
  return l2InBase64;
};
const TAG_LENGTH_BIT = 128;
const TAG_LENGTH_BYTE = TAG_LENGTH_BIT / 8;
const IV_LENGTH_BYTE = 12;
// ! DO NOT tracking on ecrypt shard
// * Already tracking on backup shard
const encryptShard = async params => {
  try {
    const {
      waypointToken,
      recoveryPassword,
      clientShard
    } = params;
    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH_BYTE)); // Generate a 12-byte IV for AES-GCM
    const shardInBytes = toBytes.stringToBytes(clientShard);
    const key = await headless_action_helpers_key.deriveKey(waypointToken, recoveryPassword);
    const content = await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv,
      tagLength: TAG_LENGTH_BIT
    }, key, shardInBytes);
    const cipherText = new Uint8Array(content.slice(0, content.byteLength - TAG_LENGTH_BYTE));
    const authTag = new Uint8Array(content.slice(content.byteLength - TAG_LENGTH_BYTE));
    const packed = packEncryptedContent(cipherText, iv, authTag);
    return packed;
  } catch (error) {
    throw new headless_error_client.HeadlessClientError({
      cause: error,
      code: headless_error_client.HeadlessClientErrorCode.EncryptClientShardError,
      message: "Unable to encrypt the client shard."
    });
  }
};

exports.IV_LENGTH_BYTE = IV_LENGTH_BYTE;
exports.TAG_LENGTH_BYTE = TAG_LENGTH_BYTE;
exports.encryptShard = encryptShard;
