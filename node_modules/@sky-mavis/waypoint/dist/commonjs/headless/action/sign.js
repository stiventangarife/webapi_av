'use strict';

var headless_proto_rpc = require('../proto/rpc.js');
var headless_proto_sign = require('../proto/sign.js');
var headless_utils_convertor = require('../utils/convertor.js');
var headless_utils_signature = require('../utils/signature.js');
var headless_action_helpers_authenticate = require('./helpers/authenticate.js');
var headless_action_helpers_getSignHandler = require('./helpers/get-sign-handler.js');
var headless_action_helpers_openSocket = require('./helpers/open-socket.js');
var headless_action_helpers_sendRoundData = require('./helpers/send-round-data.js');
var headless_action_helpers_triggerSign = require('./helpers/trigger-sign.js');
var keccak256 = require('../../keccak256-DkMFbAQi.js');
var toBinary = require('../../to-binary-B8Z0Mr_g.js');
var file = require('../../file-D9-_A4DE.js');
require('../../enum-CbdizYms.js');
require('../../toBytes-Dmnw03lt.js');
require('../../base-BPC6VLRS.js');
require('../../size-BDN9jZuU.js');
require('../../secp256k1-CzvWuxSM.js');
require('../../sha256-CLylCSfy.js');
require('../../utils-U8Z-__N5.js');
require('../error/client.js');
require('../error/server.js');
require('../proto/auth.js');
require('../utils/token.js');
require('../../index-Pma4qYcb.js');
require('../../v4-D8BIpzex.js');
require('../wasm/create.js');
require('../wasm/instantiate.js');

const sendSignMessageRequest = (socket, rawMessage) => {
  const signRequest = file.create(headless_proto_sign.SignRequestSchema, {
    params: headless_utils_convertor.jsonToBytes(headless_utils_convertor.hexToBase64(rawMessage)),
    type: headless_proto_sign.SignType.MESSAGE
  });
  const frame = file.create(headless_proto_rpc.FrameSchema, {
    type: headless_proto_rpc.Type.DATA,
    data: toBinary.toBinary(headless_proto_sign.SignRequestSchema, signRequest)
  });
  socket.send(toBinary.toBinary(headless_proto_rpc.FrameSchema, frame));
};
const _sign = async params => {
  const {
    waypointToken,
    clientShard,
    rawMessage,
    wasmUrl,
    wsUrl
  } = params;
  const keccakMessage = keccak256.keccak256(rawMessage, "bytes");
  console.debug("🔏 SIGN: start");
  const signHandler = await headless_action_helpers_getSignHandler.wasmGetSignHandler(wasmUrl);
  console.debug("🔏 SIGN: wasm is ready");
  const socket = await headless_action_helpers_openSocket.openSocket(`${wsUrl}/v1/public/ws/sign-v2`);
  const {
    waitAndDequeue
  } = headless_action_helpers_openSocket.createFrameQueue(socket);
  console.debug("🔏 SIGN: socket is ready");
  try {
    headless_action_helpers_authenticate.sendAuthenticate(socket, waypointToken);
    const authFrame = await waitAndDequeue();
    const authData = headless_action_helpers_authenticate.decodeAuthenticateData(authFrame);
    console.debug("🔏 SIGN: authenticated", authData.uuid);
    const signResultPromise = headless_action_helpers_triggerSign.wasmTriggerSign(signHandler, keccakMessage, clientShard);
    console.debug("🔏 SIGN: trigger wasm sign");
    sendSignMessageRequest(socket, rawMessage);
    console.debug("🔏 SIGN: trigger socket sign");
    const sessionFrame = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeSessionAndTransferToWasm(signHandler, sessionFrame);
    const socketR1 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR1);
    console.debug("🔏 SIGN: socket - round 1");
    const wasmR1 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR1);
    console.debug("🔏 SIGN: wasm - round 1");
    const socketR2 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR2);
    console.debug("🔏 SIGN: socket - round 2");
    const wasmR2 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR2);
    console.debug("🔏 SIGN: wasm - round 2");
    const socketR3 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR3);
    console.debug("🔏 SIGN: socket - round 3");
    const sessionR2Frame = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeSessionAndTransferToWasm(signHandler, sessionR2Frame);
    const socketR4 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR4);
    console.debug("🔏 SIGN: socket - round 4");
    const wasmR3 = await headless_action_helpers_sendRoundData.wasmGetProtocolData(signHandler);
    headless_action_helpers_sendRoundData.sendProtocolData(socket, wasmR3);
    console.debug("🔏 SIGN: wasm - round 3");
    const socketR5 = await waitAndDequeue();
    headless_action_helpers_sendRoundData.decodeProtocolDataAndTransferToWasm(signHandler, socketR5);
    console.debug("🔏 SIGN: socket - round 5");
    const signature = await signResultPromise;
    console.debug("🔏 SIGN: done");
    return headless_utils_signature.toEthereumSignature(signature);
  } finally {
    socket.close();
  }
};

exports._sign = _sign;
