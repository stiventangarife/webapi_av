'use strict';

var base = require('./base-BPC6VLRS.js');
var toBytes = require('./toBytes-Dmnw03lt.js');
var formatGwei = require('./formatGwei-Sx3AlOf5.js');
var sha256 = require('./sha256-DGm_MAwc.js');
var size = require('./size-BDN9jZuU.js');

class NegativeOffsetError extends base.BaseError {
  constructor({
    offset
  }) {
    super(`Offset \`${offset}\` cannot be negative.`, {
      name: 'NegativeOffsetError'
    });
  }
}
class PositionOutOfBoundsError extends base.BaseError {
  constructor({
    length,
    position
  }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, {
      name: 'PositionOutOfBoundsError'
    });
  }
}
class RecursiveReadLimitExceededError extends base.BaseError {
  constructor({
    count,
    limit
  }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, {
      name: 'RecursiveReadLimitExceededError'
    });
  }
}

const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({
      count: this.recursiveReadCount + 1,
      limit: this.recursiveReadLimit
    });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({
      length: this.bytes.length,
      position
    });
  },
  decrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({
      offset
    });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({
      offset
    });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0) this.recursiveReadCount++;
  }
};
function createCursor(bytes, {
  recursiveReadLimit = 8_192
} = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}

function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === undefined || value === false) return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join('\n');
}
class FeeConflictError extends base.BaseError {
  constructor() {
    super(['Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.', 'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.'].join('\n'), {
      name: 'FeeConflictError'
    });
  }
}
class InvalidLegacyVError extends base.BaseError {
  constructor({
    v
  }) {
    super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
      name: 'InvalidLegacyVError'
    });
  }
}
class InvalidSerializableTransactionError extends base.BaseError {
  constructor({
    transaction
  }) {
    super('Cannot infer a transaction type from provided transaction.', {
      metaMessages: ['Provided Transaction:', '{', prettyPrint(transaction), '}', '', 'To infer the type, either provide:', '- a `type` to the Transaction, or', '- an EIP-1559 Transaction with `maxFeePerGas`, or', '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or', '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or', '- an EIP-7702 Transaction with `authorizationList`, or', '- a Legacy Transaction with `gasPrice`'],
      name: 'InvalidSerializableTransactionError'
    });
  }
}
class InvalidStorageKeySizeError extends base.BaseError {
  constructor({
    storageKey
  }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, {
      name: 'InvalidStorageKeySizeError'
    });
  }
}

function toRlp(bytes, to = 'hex') {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === 'hex') return toBytes.bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55) return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(0xc0 + bodyLength);
      } else {
        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);
      }
      for (const {
        encode
      } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === 'string' ? toBytes.hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 0x80) return 1;
    if (bytes.length <= 55) return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 0x80) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(0x80 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8) return 1;
  if (length < 2 ** 16) return 2;
  if (length < 2 ** 24) return 3;
  if (length < 2 ** 32) return 4;
  throw new base.BaseError('Length is too large.');
}

class ExecutionRevertedError extends base.BaseError {
  constructor({
    cause,
    message
  } = {}) {
    const reason = message?.replace('execution reverted: ', '')?.replace('execution reverted', '');
    super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
      cause,
      name: 'ExecutionRevertedError'
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends base.BaseError {
  constructor({
    cause,
    maxFeePerGas
  } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei.formatGwei(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause,
      name: 'FeeCapTooHighError'
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends base.BaseError {
  constructor({
    cause,
    maxFeePerGas
  } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei.formatGwei(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
      cause,
      name: 'FeeCapTooLowError'
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends base.BaseError {
  constructor({
    cause,
    nonce
  } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, {
      cause,
      name: 'NonceTooHighError'
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends base.BaseError {
  constructor({
    cause,
    nonce
  } = {}) {
    super([`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`, 'Try increasing the nonce or find the latest nonce with `getTransactionCount`.'].join('\n'), {
      cause,
      name: 'NonceTooLowError'
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends base.BaseError {
  constructor({
    cause,
    nonce
  } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, {
      cause,
      name: 'NonceMaxValueError'
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends base.BaseError {
  constructor({
    cause
  } = {}) {
    super(['The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.'].join('\n'), {
      cause,
      metaMessages: ['This error could arise when the account does not have enough funds to:', ' - pay for the total gas fee,', ' - pay for the value to send.', ' ', 'The cost of the transaction is calculated as `gas * gas fee + value`, where:', ' - `gas` is the amount of gas needed for transaction to execute,', ' - `gas fee` is the gas fee,', ' - `value` is the amount of ether to send to the recipient.'],
      name: 'InsufficientFundsError'
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends base.BaseError {
  constructor({
    cause,
    gas
  } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
      cause,
      name: 'IntrinsicGasTooHighError'
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends base.BaseError {
  constructor({
    cause,
    gas
  } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
      cause,
      name: 'IntrinsicGasTooLowError'
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends base.BaseError {
  constructor({
    cause
  }) {
    super('The transaction type is not supported for this chain.', {
      cause,
      name: 'TransactionTypeNotSupportedError'
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends base.BaseError {
  constructor({
    cause,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = {}) {
    super([`The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei.formatGwei(maxPriorityFeePerGas)} gwei` : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei.formatGwei(maxFeePerGas)} gwei` : ''}).`].join('\n'), {
      cause,
      name: 'TipAboveFeeCapError'
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends base.BaseError {
  constructor({
    cause
  }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause,
      name: 'UnknownNodeError'
    });
  }
}

const maxUint256 = 2n ** 256n - 1n;

/**
 * Compute commitments from a list of blobs.
 *
 * @example
 * ```ts
 * import { blobsToCommitments, toBlobs } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * ```
 */
function blobsToCommitments(parameters) {
  const {
    kzg
  } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => toBytes.hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === 'bytes' ? commitments : commitments.map(x => toBytes.bytesToHex(x));
}

/**
 * Compute the proofs for a list of blobs and their commitments.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 * ```
 */
function blobsToProofs(parameters) {
  const {
    kzg
  } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => toBytes.hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === 'string' ? parameters.commitments.map(x => toBytes.hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === 'bytes' ? proofs : proofs.map(x => toBytes.bytesToHex(x));
}

/**
 * Transform a commitment to it's versioned hash.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentToVersionedHash,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const [commitment] = blobsToCommitments({ blobs, kzg })
 * const versionedHash = commitmentToVersionedHash({ commitment })
 * ```
 */
function commitmentToVersionedHash(parameters) {
  const {
    commitment,
    version = 1
  } = parameters;
  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes');
  const versionedHash = sha256.sha256(commitment, 'bytes');
  versionedHash.set([version], 0);
  return to === 'bytes' ? versionedHash : toBytes.bytesToHex(versionedHash);
}

/**
 * Transform a list of commitments to their versioned hashes.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentsToVersionedHashes,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const versionedHashes = commitmentsToVersionedHashes({ commitments })
 * ```
 */
function commitmentsToVersionedHashes(parameters) {
  const {
    commitments,
    version
  } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes');
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version
    }));
  }
  return hashes;
}

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
/** Blob limit per transaction. */
const blobsPerTransaction = 6;
/** The number of bytes in a BLS scalar field element. */
const bytesPerFieldElement = 32;
/** The number of field elements in a blob. */
const fieldElementsPerBlob = 4096;
/** The number of bytes in a blob. */
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
/** Blob bytes limit per transaction. */
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -
// terminator byte (0x80).
1 -
// zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
const versionedHashVersionKzg = 1;

class BlobSizeTooLargeError extends base.BaseError {
  constructor({
    maxSize,
    size
  }) {
    super('Blob size is too large.', {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],
      name: 'BlobSizeTooLargeError'
    });
  }
}
class EmptyBlobError extends base.BaseError {
  constructor() {
    super('Blob data must not be empty.', {
      name: 'EmptyBlobError'
    });
  }
}
class InvalidVersionedHashSizeError extends base.BaseError {
  constructor({
    hash,
    size
  }) {
    super(`Versioned hash "${hash}" size is invalid.`, {
      metaMessages: ['Expected: 32', `Received: ${size}`],
      name: 'InvalidVersionedHashSizeError'
    });
  }
}
class InvalidVersionedHashVersionError extends base.BaseError {
  constructor({
    hash,
    version
  }) {
    super(`Versioned hash "${hash}" version is invalid.`, {
      metaMessages: [`Expected: ${versionedHashVersionKzg}`, `Received: ${version}`],
      name: 'InvalidVersionedHashVersionError'
    });
  }
}

/**
 * Transforms arbitrary data to blobs.
 *
 * @example
 * ```ts
 * import { toBlobs, stringToHex } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * ```
 */
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');
  const data = typeof parameters.data === 'string' ? toBytes.hexToBytes(parameters.data) : parameters.data;
  const size_ = size.size(data);
  if (!size_) throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({
    maxSize: maxBytesPerTransaction,
    size: size_
  });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size = 0;
    while (size < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      // Push a zero byte so the field element doesn't overflow the BLS modulus.
      blob.pushByte(0x00);
      // Push the current segment of data bytes.
      blob.pushBytes(bytes);
      // If we detect that the current segment of data bytes is less than 31 bytes,
      // we can stop processing and push a terminator byte to indicate the end of the blob.
      if (bytes.length < 31) {
        blob.pushByte(0x80);
        active = false;
        break;
      }
      size++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === 'bytes' ? blobs.map(x => x.bytes) : blobs.map(x => toBytes.bytesToHex(x.bytes));
}

/**
 * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.
 *
 * @example
 * ```ts
 * import { toBlobSidecars, stringToHex } from 'viem'
 *
 * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })
 * ```
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs,
 *   blobsToProofs,
 *   toBlobSidecars,
 *   stringToHex
 * } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 *
 * const sidecars = toBlobSidecars({ blobs, commitments, proofs })
 * ```
 */
function toBlobSidecars(parameters) {
  const {
    data,
    kzg,
    to
  } = parameters;
  const blobs = parameters.blobs ?? toBlobs({
    data: data,
    to
  });
  const commitments = parameters.commitments ?? blobsToCommitments({
    blobs,
    kzg: kzg,
    to
  });
  const proofs = parameters.proofs ?? blobsToProofs({
    blobs,
    commitments,
    kzg: kzg,
    to
  });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++) sidecars.push({
    blob: blobs[i],
    commitment: commitments[i],
    proof: proofs[i]
  });
  return sidecars;
}

function getTransactionType(transaction) {
  if (transaction.type) return transaction.type;
  if (typeof transaction.authorizationList !== 'undefined') return 'eip7702';
  if (typeof transaction.blobs !== 'undefined' || typeof transaction.blobVersionedHashes !== 'undefined' || typeof transaction.maxFeePerBlobGas !== 'undefined' || typeof transaction.sidecars !== 'undefined') return 'eip4844';
  if (typeof transaction.maxFeePerGas !== 'undefined' || typeof transaction.maxPriorityFeePerGas !== 'undefined') {
    return 'eip1559';
  }
  if (typeof transaction.gasPrice !== 'undefined') {
    if (typeof transaction.accessList !== 'undefined') return 'eip2930';
    return 'legacy';
  }
  throw new InvalidSerializableTransactionError({
    transaction
  });
}

exports.EmptyBlobError = EmptyBlobError;
exports.ExecutionRevertedError = ExecutionRevertedError;
exports.FeeCapTooHighError = FeeCapTooHighError;
exports.FeeCapTooLowError = FeeCapTooLowError;
exports.FeeConflictError = FeeConflictError;
exports.InsufficientFundsError = InsufficientFundsError;
exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
exports.InvalidLegacyVError = InvalidLegacyVError;
exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
exports.InvalidVersionedHashSizeError = InvalidVersionedHashSizeError;
exports.InvalidVersionedHashVersionError = InvalidVersionedHashVersionError;
exports.NonceMaxValueError = NonceMaxValueError;
exports.NonceTooHighError = NonceTooHighError;
exports.NonceTooLowError = NonceTooLowError;
exports.TipAboveFeeCapError = TipAboveFeeCapError;
exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
exports.UnknownNodeError = UnknownNodeError;
exports.blobsToCommitments = blobsToCommitments;
exports.blobsToProofs = blobsToProofs;
exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
exports.getTransactionType = getTransactionType;
exports.maxUint256 = maxUint256;
exports.prettyPrint = prettyPrint;
exports.toBlobSidecars = toBlobSidecars;
exports.toRlp = toRlp;
exports.versionedHashVersionKzg = versionedHashVersionKzg;
