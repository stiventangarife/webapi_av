'use strict';

var common_defer = require('./defer.js');
var common_waypointError = require('./waypoint-error.js');
var v4 = require('../v4-D8BIpzex.js');
require('../rpc-BJmuIVLE.js');
require('../base-BPC6VLRS.js');

const DELAY_INTERVAL = 1_000;
class CommunicateHelper {
  pendingEvents = new Map();
  windowMonitorIntervals = new Map();
  origin;
  eventHandler;
  constructor(origin) {
    if (typeof window === "undefined") {
      // eslint-disable-next-line no-console
      console.warn("CommunicateHelper can only be used in browser environment");
      return;
    }
    this.origin = origin;
    this.eventHandler = this.createEventHandler();
    this.initializeEventListeners();
  }
  createEventHandler() {
    return event => {
      if (event.origin !== this.origin) return;
      const callbackMessage = event.data;
      if (!this.isValidCallbackMessage(callbackMessage)) return;
      this.handleResponse(callbackMessage);
    };
  }
  isValidCallbackMessage(message) {
    return typeof message === "object" && message !== null && "state" in message && "type" in message;
  }
  initializeEventListeners() {
    window.addEventListener("message", this.eventHandler);
    window.addEventListener("beforeunload", () => {
      this.cleanup();
    });
  }
  handleResponse(message) {
    const {
      state: requestId,
      type
    } = message;
    const deferredPromise = this.pendingEvents.get(requestId);
    const monitorInterval = this.windowMonitorIntervals.get(requestId);
    if (!deferredPromise || !(typeof deferredPromise !== "function")) return;
    if (monitorInterval) {
      this.windowMonitorIntervals.delete(requestId);
      clearInterval(monitorInterval);
    }
    this.pendingEvents.delete(requestId);
    switch (type) {
      case "fail":
        {
          const err = common_waypointError.normalizeWaypointError(message.error);
          return deferredPromise.reject(err);
        }
      default:
        {
          const objectOrStringData = this.parseSuccessResponse(message.data);
          return deferredPromise.resolve(objectOrStringData);
        }
    }
  }
  parseSuccessResponse(data) {
    try {
      return typeof data === "string" ? JSON.parse(data) : data;
    } catch {
      return data;
    }
  }
  monitorWindowClosing(params) {
    const {
      requestId,
      window: targetWindow
    } = params;
    const monitorInterval = setInterval(() => {
      if (targetWindow?.closed && this.hasPendingRequest(requestId)) {
        this.handleResponse({
          state: requestId,
          type: "fail",
          error: common_waypointError.WaypointErrorMap.WALLET_USER_CANCEL
        });
      }
    }, DELAY_INTERVAL);
    this.windowMonitorIntervals.set(requestId, monitorInterval);
  }
  hasPendingRequest(requestId) {
    return this.pendingEvents.has(requestId) && this.windowMonitorIntervals.has(requestId);
  }
  async sendRequest(action) {
    const id = v4.v4();
    const responseHandler = new common_defer.Deferred();
    this.pendingEvents.set(id, responseHandler);
    const referencedWindow = await action(id);
    if (referencedWindow) {
      this.monitorWindowClosing({
        window: referencedWindow,
        requestId: id
      });
    }
    return responseHandler.promise;
  }
  cleanup() {
    window.removeEventListener("message", this.eventHandler);
    this.windowMonitorIntervals.forEach(interval => clearInterval(interval));
    this.windowMonitorIntervals.clear();
    this.pendingEvents.clear();
  }
}

exports.CommunicateHelper = CommunicateHelper;
