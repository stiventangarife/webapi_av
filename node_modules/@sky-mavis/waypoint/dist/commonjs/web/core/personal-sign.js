'use strict';

var common_popup = require('../../common/popup.js');
var isAddressEqual = require('../../isAddressEqual-QoNFma_v.js');
var rpc = require('../../rpc-BJmuIVLE.js');
var size = require('../../size-BDN9jZuU.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../common/Snackbar.js');
require('../../isAddress-Ajbo9xO8.js');
require('../../base-BPC6VLRS.js');
require('../../keccak256-DkMFbAQi.js');
require('../../utils-U8Z-__N5.js');

const personalSign = async ({
  config,
  params,
  expectAddress,
  clientId,
  waypointOrigin,
  communicateHelper
}) => {
  const [data, address] = params;
  if (address && expectAddress && !isAddressEqual.isAddressEqual(address, expectAddress)) {
    const err = new Error("personal_sign: current address is different from required address");
    throw new rpc.UnauthorizedProviderError(err);
  }
  // * Ronin Waypoint only accept raw string message - NOT hex
  const message = !size.isHex(data) ? data : toBytes.hexToString(data);
  if (!message) {
    const err = new Error("personal_sign: message is NOT define");
    throw new rpc.InvalidParamsRpcError(err);
  }
  const signature = await communicateHelper.sendRequest(state => common_popup.openPopup(`${waypointOrigin}/wallet/sign`, {
    state,
    clientId,
    origin: window.location.origin,
    expectAddress,
    message,
    ...config
  }));
  if (!size.isHex(signature)) {
    const err = new Error("personal_sign: signature is not valid");
    throw new rpc.InternalRpcError(err);
  }
  return signature;
};

exports.personalSign = personalSign;
