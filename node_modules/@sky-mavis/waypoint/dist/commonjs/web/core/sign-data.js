'use strict';

var common_popup = require('../../common/popup.js');
var rpc = require('../../rpc-BJmuIVLE.js');
var isAddressEqual = require('../../isAddressEqual-QoNFma_v.js');
var size = require('../../size-BDN9jZuU.js');
var toBytes = require('../../toBytes-Dmnw03lt.js');
require('../../common/Snackbar.js');
require('../../base-BPC6VLRS.js');
require('../../isAddress-Ajbo9xO8.js');
require('../../keccak256-DkMFbAQi.js');
require('../../utils-U8Z-__N5.js');

const REQUIRED_PROPERTIES = ["types", "domain", "primaryType", "message"];
const isValidTypedData = typedData => REQUIRED_PROPERTIES.every(k => k in typedData);
const transformTypedData = (data, chainId) => {
  let typedData;
  try {
    if (typeof data === "string") {
      typedData = JSON.parse(data);
    } else {
      typedData = data;
    }
  } catch (_err) {
    const parseError = new Error("eth_signTypedData_v4: could NOT parse typed data");
    throw new rpc.InvalidParamsRpcError(parseError);
  }
  if (!isValidTypedData(typedData)) {
    const err = new Error(`eth_signTypedData_v4: invalid typed data - required ${REQUIRED_PROPERTIES.join(", ")}`);
    throw new rpc.InvalidParamsRpcError(err);
  }
  const rawChainId = typedData.domain?.chainId;
  if (rawChainId === undefined) {
    const chainIdError = new Error(`eth_signTypedData_v4: chainId is NOT defined - expected ${chainId}`);
    throw new rpc.InvalidParamsRpcError(chainIdError);
  }
  const requestChainId = size.isHex(rawChainId) ? toBytes.hexToNumber(rawChainId) : +rawChainId;
  if (chainId !== requestChainId) {
    const chainIdError = new Error(`eth_signTypedData_v4: chainId is NOT valid - expected ${chainId}`);
    throw new rpc.InvalidParamsRpcError(chainIdError);
  }
  return typedData;
};
const signTypedDataV4 = async ({
  config,
  params,
  expectAddress,
  clientId,
  chainId,
  waypointOrigin,
  communicateHelper
}) => {
  const [address, data] = params;
  if (!data) throw new rpc.InvalidParamsRpcError(new Error("eth_signTypedData_v4: data is NOT define"));
  if (address && expectAddress && !isAddressEqual.isAddressEqual(address, expectAddress)) {
    throw new rpc.UnauthorizedProviderError(new Error("eth_signTypedData_v4: current address is different from required address"));
  }
  const typedData = transformTypedData(data, chainId);
  try {
    const signature = await communicateHelper.sendRequest(state => common_popup.openPopup(`${waypointOrigin}/wallet/sign`, {
      state,
      clientId,
      origin: window.location.origin,
      chainId,
      expectAddress,
      typedData: JSON.stringify(typedData),
      ...config
    }));
    if (!size.isHex(signature)) {
      throw new Error("eth_signTypedData_v4: signature is not valid");
    }
    return signature;
  } catch (err) {
    if (err instanceof Error) {
      throw new rpc.InternalRpcError(err);
    }
    const unknownErr = new Error("eth_signTypedData_v4: unknown error");
    throw new rpc.InternalRpcError(unknownErr);
  }
};

exports.signTypedDataV4 = signTypedDataV4;
