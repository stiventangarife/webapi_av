'use strict';

var _polyfillNode_events = require('../_polyfill-node.events-Cg_JIuru.js');
var common_chain = require('../common/chain.js');
var common_communicate = require('../common/communicate.js');
var common_eip1193 = require('../common/eip1193.js');
var common_gate = require('../common/gate.js');
var common_popup = require('../common/popup.js');
var common_scope = require('../common/scope.js');
var common_version = require('../common/version.js');
var web_core_personalSign = require('./core/personal-sign.js');
var web_core_sendTx = require('./core/send-tx.js');
var web_core_signData = require('./core/sign-data.js');
var web_utils_storage = require('./utils/storage.js');
var web_utils_validateAddress = require('./utils/validate-address.js');
var rpc = require('../rpc-BJmuIVLE.js');
var http = require('../http-jAHgRxFF.js');
var toBytes = require('../toBytes-Dmnw03lt.js');
require('../saigon-DYBomzZQ.js');
require('../common/defer.js');
require('../common/waypoint-error.js');
require('../v4-D8BIpzex.js');
require('../common/Snackbar.js');
require('../isAddressEqual-QoNFma_v.js');
require('../isAddress-Ajbo9xO8.js');
require('../base-BPC6VLRS.js');
require('../keccak256-DkMFbAQi.js');
require('../utils-U8Z-__N5.js');
require('../size-BDN9jZuU.js');

/**
 * A JavaScript Ethereum Provider API for consistency across clients and applications.
 *
 * This provider is designed to easily integrate with Ronin Waypoint.
 *
 * Use `create` function to create a new instance."
import { EventEmitter } from "events"
import { A, ChainDisconnectedError, Client, createClient, EIP1193Parameters, http, ProviderDisconnectedError, toHex, UnauthorizedProviderError } from "viem
 *
 * @example
 * import { WaypointProvider } from "@sky-mavis/waypoint"
 *
 * const idWalletProvider = WaypointProvider.create({
 *  clientId: "YOUR_CLIENT_ID",
 *  chainId: ronin.chainId,
 * })
 */
class WaypointProvider extends _polyfillNode_events.EventEmitter {
  clientId;
  waypointOrigin;
  redirectUrl;
  scopes;
  chainId;
  address;
  viemClient;
  communicateHelper;
  config;
  constructor(options) {
    super();
    const {
      clientId,
      chainId,
      scopes = [],
      waypointOrigin = common_gate.RONIN_WAYPOINT_ORIGIN_PROD,
      redirectUrl = typeof window !== "undefined" ? window.location.origin : "",
      source,
      popupCloseDelay,
      theme
    } = options;
    this.clientId = clientId;
    this.waypointOrigin = waypointOrigin;
    this.redirectUrl = redirectUrl;
    this.chainId = chainId;
    this.scopes = this.addDefaultScopes(scopes);
    this.communicateHelper = new common_communicate.CommunicateHelper(waypointOrigin);
    this.viemClient = this.createViemClient(chainId);
    this.config = {
      source: source ?? `${common_version.name}@${common_version.version}`,
      popupCloseDelay,
      theme
    };
  }
  createViemClient(chainId) {
    const chain = common_chain.VIEM_CHAIN_MAPPING[chainId];
    if (!chain) {
      const err = new Error(`Chain ${chainId} is not supported.`);
      throw new rpc.ChainDisconnectedError(err);
    }
    return http.createClient({
      chain: common_chain.VIEM_CHAIN_MAPPING[chainId],
      transport: http.http()
    });
  }
  addDefaultScopes(scopes) {
    const newScopes = [...scopes];
    if (!newScopes.includes("openid")) {
      newScopes.push("openid");
    }
    if (!newScopes.includes("wallet")) {
      newScopes.push("wallet");
    }
    return newScopes;
  }
  /**
   * Creates a new WaypointProvider instance.
   *
   * @param options Options for WaypointProvider.
   *
   * @returns WaypointProvider instance.
   *
   * @example
   * import { WaypointProvider } from "@sky-mavis/waypoint"
   *
   * const idWalletProvider = WaypointProvider.create({
   *  clientId: "YOUR_CLIENT_ID",
   *  chainId: ronin.chainId,
   * })
   */
  static create = options => {
    return new WaypointProvider(options);
  };
  getIdAddress = () => {
    if (this.address) return this.address;
    const storedAddress = web_utils_storage.getStorage(web_utils_storage.STORAGE_ADDRESS_KEY) || "";
    return web_utils_validateAddress.validateIdAddress(storedAddress);
  };
  getIdAddressOrConnect = async () => {
    const address = this.getIdAddress();
    if (address) return address;
    const result = await this.connect();
    return result.address;
  };
  /**
   * Connects to Ronin Waypoint provider and retrieves authorization data & user wallet address.
   *
   * @returns The access token and address.
   */
  connect = async () => {
    const {
      waypointOrigin,
      clientId,
      redirectUrl,
      scopes,
      communicateHelper,
      chainId,
      config
    } = this;
    const authData = await communicateHelper.sendRequest(state => common_popup.openPopup(`${waypointOrigin}/client/${clientId}/authorize`, {
      state,
      redirect: redirectUrl,
      origin: window.location.origin,
      scope: common_scope.getScopesParams(scopes),
      ...config
    }));
    return this.handleAuthData(authData, chainId);
  };
  createKeylessWallet = async () => {
    const {
      waypointOrigin,
      clientId,
      redirectUrl,
      communicateHelper,
      chainId,
      config
    } = this;
    const authData = await communicateHelper.sendRequest(state => common_popup.openPopup(`${waypointOrigin}/wallet/setup/introduce`, {
      state,
      clientId,
      redirect: redirectUrl,
      origin: window.location.origin,
      ...config
    }));
    return this.handleAuthData(authData, chainId);
  };
  handleAuthData = (authData, chainId) => {
    const {
      id_token: token,
      address: rawAddress
    } = authData;
    const address = web_utils_validateAddress.validateIdAddress(rawAddress);
    if (!address) {
      const err = new Error("Ronin Waypoint do NOT return valid address");
      throw new rpc.UnauthorizedProviderError(err);
    }
    web_utils_storage.setStorage(web_utils_storage.STORAGE_ADDRESS_KEY, address);
    this.address = address;
    const addresses = [address];
    this.emit(common_eip1193.Eip1193EventName.accountsChanged, addresses);
    this.emit(common_eip1193.Eip1193EventName.connect, {
      chainId
    });
    return {
      token,
      address
    };
  };
  /**
   * Disconnect from Ronin Waypoint provider and clear the cached address in localStorage.
   */
  disconnect = () => {
    const shouldEmitDisconnectEvent = !!this.address;
    web_utils_storage.removeStorage(web_utils_storage.STORAGE_ADDRESS_KEY);
    this.address = undefined;
    if (shouldEmitDisconnectEvent) {
      const err = new Error("The provider is disconnected from all chains.");
      const providerErr = new rpc.ProviderDisconnectedError(err);
      this.emit(common_eip1193.Eip1193EventName.accountsChanged, []);
      this.emit(common_eip1193.Eip1193EventName.disconnect, providerErr);
    }
  };
  /**
   * A JavaScript Ethereum Provider API for consistency across clients and applications.
   *
   * Makes an Ethereum RPC method call.
   *
   * https://eips.ethereum.org/EIPS/eip-1193
   */
  request = async args => {
    const {
      clientId,
      waypointOrigin,
      communicateHelper,
      chainId,
      viemClient,
      connect,
      getIdAddress,
      getIdAddressOrConnect,
      config
    } = this;
    const {
      method,
      params
    } = args;
    switch (method) {
      case "eth_chainId":
        return toBytes.toHex(chainId);
      case "eth_accounts":
        {
          const address = getIdAddress();
          const result = address ? [address] : [];
          return result;
        }
      // * Ronin Waypoint is not like other providers, it need open popup to authorize & get address
      // * eth_requestAccounts should NOT get address from localStorage cache
      // * if user change address in Ronin Waypoint, it should get new address
      case "eth_requestAccounts":
        {
          const {
            address: newAddress
          } = await connect();
          return [newAddress];
        }
      case "personal_sign":
        {
          const expectAddress = await getIdAddressOrConnect();
          return web_core_personalSign.personalSign({
            config,
            params,
            expectAddress,
            clientId,
            waypointOrigin,
            communicateHelper
          });
        }
      case "eth_signTypedData_v4":
        {
          const expectAddress = await getIdAddressOrConnect();
          return web_core_signData.signTypedDataV4({
            config,
            params,
            chainId,
            expectAddress,
            clientId,
            waypointOrigin,
            communicateHelper
          });
        }
      case "eth_sendTransaction":
        {
          const expectAddress = await getIdAddressOrConnect();
          return web_core_sendTx.sendTransaction({
            config,
            params,
            chainId,
            expectAddress,
            clientId,
            waypointOrigin,
            communicateHelper
          });
        }
      default:
        {
          return viemClient.request(args);
        }
    }
  };
}

exports.WaypointProvider = WaypointProvider;
