'use strict';

var common_communicate = require('../common/communicate.js');
var common_crypto = require('../common/crypto.js');
var common_gate = require('../common/gate.js');
var common_popup = require('../common/popup.js');
var common_scope = require('../common/scope.js');
var web_utils_validateAddress = require('./utils/validate-address.js');
var v4 = require('../v4-D8BIpzex.js');
require('../common/defer.js');
require('../common/waypoint-error.js');
require('../rpc-BJmuIVLE.js');
require('../base-BPC6VLRS.js');
require('../common/Snackbar.js');
require('../isAddress-Ajbo9xO8.js');
require('../toBytes-Dmnw03lt.js');
require('../size-BDN9jZuU.js');
require('../keccak256-DkMFbAQi.js');
require('../utils-U8Z-__N5.js');

const getPKCEParams = usePKCE => {
  if (!usePKCE) return {};
  const codeVerifier = common_crypto.generateRandomString();
  return {
    response_type: "code",
    code_challenge_algo: "S256",
    code_challenge: common_crypto.generateCodeChallenge(codeVerifier),
    codeVerifier
  };
};
/**
 * Authorize a user via Ronin Waypoint, returning an token and user address.
 *
 * @param opts Options for authorization.
 * @returns Authorization result including token and user addresses, or undefined in case of redirect.
 *
 * @example
 * import { authorize } from "@sky-mavis/waypoint"
 *
 * const { token, address } = await authorize({
 *  mode: "popup",
 *  clientId: "YOUR_CLIENT_ID",
 * })
 */
const authorize = async opts => {
  const {
    mode,
    clientId,
    scopes,
    checks = [],
    waypointOrigin = common_gate.RONIN_WAYPOINT_ORIGIN_PROD,
    redirectUrl = window.location.origin,
    ...restConfig
  } = opts;
  const isPKCE = checks.includes("pkce");
  const {
    codeVerifier,
    ...pkceParams
  } = getPKCEParams(isPKCE);
  const authorizeUrl = `${waypointOrigin}/client/${clientId}/authorize`;
  const baseParams = {
    redirect: redirectUrl,
    scope: common_scope.getScopesParams(scopes),
    ...pkceParams,
    ...restConfig
  };
  if (mode === "redirect") {
    const redirectParams = {
      ...baseParams,
      state: opts.state ?? v4.v4()
    };
    common_popup.replaceUrl(authorizeUrl, redirectParams);
    return isPKCE ? {
      codeVerifier
    } : undefined;
  }
  const helper = new common_communicate.CommunicateHelper(waypointOrigin);
  const popupParams = {
    ...baseParams,
    origin: window.location.origin
  };
  if (isPKCE) {
    const pkceAuthData = await helper.sendRequest(state => common_popup.openPopup(authorizeUrl, {
      ...popupParams,
      state
    }));
    return {
      codeVerifier: codeVerifier,
      authorizationCode: pkceAuthData.authorization_code
    };
  }
  const authData = await helper.sendRequest(state => common_popup.openPopup(authorizeUrl, {
    ...popupParams,
    state
  }));
  return {
    token: authData?.id_token,
    address: web_utils_validateAddress.validateIdAddress(authData?.address),
    secondaryAddress: web_utils_validateAddress.validateIdAddress(authData?.secondary_address)
  };
};
/**
 * Parse the redirect URL after authorization.
 * This function should be called in the redirect URL page.
 *
 * @returns Parsed data from the redirect URL.
 *
 * @example
 * const { state, token, address } = parseRedirectUrl()
 */
const parseRedirectUrl = () => {
  const url = new URL(window.location.href);
  const method = url.searchParams.get("method");
  if (method !== "auth") {
    throw "parseRedirectUrl: invalid method";
  }
  const type = url.searchParams.get("type");
  if (type !== "success") {
    throw "parseRedirectUrl: authorization failed";
  }
  const state = url.searchParams.get("state");
  const rawToken = url.searchParams.get("data");
  const rawAddress = url.searchParams.get("address");
  const secondaryAddress = url.searchParams.get("secondary_address");
  const authorizationCode = url.searchParams.get("authorization_code");
  return {
    state,
    authorizationCode,
    token: rawToken,
    address: web_utils_validateAddress.validateIdAddress(rawAddress),
    secondaryAddress: web_utils_validateAddress.validateIdAddress(secondaryAddress)
  };
};

exports.authorize = authorize;
exports.parseRedirectUrl = parseRedirectUrl;
