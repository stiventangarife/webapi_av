'use strict';

var publicKeyToAddress = require('./publicKeyToAddress-7k7v6GXz.js');
var size = require('./size-BDN9jZuU.js');
var toBytes = require('./toBytes-Dmnw03lt.js');

async function recoverPublicKey({
  hash,
  signature
}) {
  const hashHex = size.isHex(hash) ? hash : toBytes.toHex(hash);
  const {
    secp256k1
  } = await Promise.resolve().then(function () { return require('./secp256k1-CzvWuxSM.js'); });
  const signature_ = (() => {
    // typeof signature: `Signature`
    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
      const {
        r,
        s,
        v,
        yParity
      } = signature;
      const yParityOrV = Number(yParity ?? v);
      const recoveryBit = toRecoveryBit(yParityOrV);
      return new secp256k1.Signature(toBytes.hexToBigInt(r), toBytes.hexToBigInt(s)).addRecoveryBit(recoveryBit);
    }
    // typeof signature: `Hex | ByteArray`
    const signatureHex = size.isHex(signature) ? signature : toBytes.toHex(signature);
    const yParityOrV = toBytes.hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;
  if (yParityOrV === 27) return 0;
  if (yParityOrV === 28) return 1;
  throw new Error('Invalid yParityOrV value');
}

async function recoverAddress({
  hash,
  signature
}) {
  return publicKeyToAddress.publicKeyToAddress(await recoverPublicKey({
    hash: hash,
    signature
  }));
}

exports.recoverAddress = recoverAddress;
