import { isEIP1559CompatibleTransaction } from '../helpers/tx-type-check.js';
import { E as EmptyBlobError, I as InvalidVersionedHashSizeError, v as versionedHashVersionKzg, a as InvalidVersionedHashVersionError, m as maxUint256, F as FeeCapTooHighError, T as TipAboveFeeCapError, b as InvalidStorageKeySizeError, g as getTransactionType, t as toRlp, c as blobsToCommitments, d as commitmentsToVersionedHashes, e as blobsToProofs, f as toBlobSidecars, h as InvalidLegacyVError } from '../../../getTransactionType-XZ1KTlkM.js';
import { b as concatHex } from '../../../concat-CZcWoY2n.js';
import { h as hexToNumber, t as toHex, b as bytesToHex, g as trim, i as hexToBigInt } from '../../../toBytes-CiKSrzpb.js';
import { i as isAddress, I as InvalidAddressError } from '../../../isAddress-D-kYvfsU.js';
import { B as BaseError } from '../../../base-CC-Hj7CW.js';
import { s as size } from '../../../size-CssOTqqV.js';
import { s as slice } from '../../../slice-BN10rAto.js';
import './common.js';
import '../../../formatGwei-BX_cgVog.js';
import '../../../sha256-BHhS4Zh9.js';
import '../../../sha256-E5MvF2nn.js';
import '../../../utils-CKEBUnDS.js';
import '../../../keccak256-0IBB9HST.js';

class InvalidChainIdError extends BaseError {
  constructor({
    chainId
  }) {
    super(typeof chainId === 'number' ? `Chain ID "${chainId}" is invalid.` : 'Chain ID is invalid.', {
      name: 'InvalidChainIdError'
    });
  }
}

function assertTransactionEIP7702(transaction) {
  const {
    authorizationList
  } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const {
        contractAddress,
        chainId
      } = authorization;
      if (!isAddress(contractAddress)) throw new InvalidAddressError({
        address: contractAddress
      });
      if (chainId <= 0) throw new InvalidChainIdError({
        chainId
      });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const {
    blobVersionedHashes
  } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0) throw new EmptyBlobError();
    for (const hash of blobVersionedHashes) {
      const size_ = size(hash);
      const version = hexToNumber(slice(hash, 0, 1));
      if (size_ !== 32) throw new InvalidVersionedHashSizeError({
        hash,
        size: size_
      });
      if (version !== versionedHashVersionKzg) throw new InvalidVersionedHashVersionError({
        hash,
        version
      });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (maxFeePerGas && maxFeePerGas > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas
  });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new TipAboveFeeCapError({
    maxFeePerGas,
    maxPriorityFeePerGas
  });
}
function assertTransactionEIP2930(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
  if (gasPrice && gasPrice > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas: gasPrice
  });
}
function assertTransactionLegacy(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (typeof chainId !== 'undefined' && chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
  if (gasPrice && gasPrice > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas: gasPrice
  });
}

/*
 * Serializes an EIP-7702 authorization list.
 */
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0) return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const {
      contractAddress,
      chainId,
      nonce,
      ...signature
    } = authorization;
    serializedAuthorizationList.push([toHex(chainId), contractAddress, nonce ? toHex(nonce) : '0x', ...toYParitySignatureArray({}, signature)]);
  }
  return serializedAuthorizationList;
}

/*
 * Serialize an  EIP-2930 access list
 * @remarks
 * Use to create a transaction serializer with support for EIP-2930 access lists
 *
 * @param accessList - Array of objects of address and arrays of Storage Keys
 * @throws InvalidAddressError, InvalidStorageKeySizeError
 * @returns Array of hex strings
 */
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0) return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const {
      address,
      storageKeys
    } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j]
        });
      }
    }
    if (!isAddress(address, {
      strict: false
    })) {
      throw new InvalidAddressError({
        address
      });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === 'eip1559') return serializeTransactionEIP1559(transaction, signature);
  if (type === 'eip2930') return serializeTransactionEIP2930(transaction, signature);
  if (type === 'eip4844') return serializeTransactionEIP4844(transaction, signature);
  if (type === 'eip7702') return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const {
    authorizationList,
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex(['0x04', toRlp([toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, serializedAuthorizationList, ...toYParitySignatureArray(transaction, signature)])]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerBlobGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.
  if (transaction.blobs && (typeof blobVersionedHashes === 'undefined' || typeof sidecars === 'undefined')) {
    const blobs = typeof transaction.blobs[0] === 'string' ? transaction.blobs : transaction.blobs.map(x => bytesToHex(x));
    const kzg = transaction.kzg;
    const commitments = blobsToCommitments({
      blobs,
      kzg
    });
    if (typeof blobVersionedHashes === 'undefined') blobVersionedHashes = commitmentsToVersionedHashes({
      commitments
    });
    if (typeof sidecars === 'undefined') {
      const proofs = blobsToProofs({
        blobs,
        commitments,
        kzg
      });
      sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs
      });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x', blobVersionedHashes ?? [], ...toYParitySignatureArray(transaction, signature)];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars) for (let i = 0; i < sidecars.length; i++) {
    const {
      blob,
      commitment,
      proof
    } = sidecars[i];
    blobs.push(blob);
    commitments.push(commitment);
    proofs.push(proof);
  }
  return concatHex(['0x03', sidecars ?
  // If sidecars are enabled, envelope turns into a "wrapper":
  toRlp([serializedTransaction, blobs, commitments, proofs]) :
  // If sidecars are disabled, standard envelope is used:
  toRlp(serializedTransaction)]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];
  return concatHex(['0x02', toRlp(serializedTransaction)]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const {
    chainId,
    gas,
    data,
    nonce,
    to,
    value,
    accessList,
    gasPrice
  } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];
  return concatHex(['0x01', toRlp(serializedTransaction)]);
}
function serializeTransactionLegacy(transaction, signature) {
  const {
    chainId = 0,
    gas,
    data,
    nonce,
    to,
    value,
    gasPrice
  } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x'];
  if (signature) {
    const v = (() => {
      // EIP-155 (inferred chainId)
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0) return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      // EIP-155 (explicit chainId)
      if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      // Pre-EIP-155 (no chainId)
      const v = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v) throw new InvalidLegacyVError({
        v: signature.v
      });
      return v;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [...serializedTransaction, toHex(v), r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
  } else if (chainId > 0) {
    serializedTransaction = [...serializedTransaction, toHex(chainId), '0x', '0x'];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const {
    v,
    yParity
  } = signature;
  if (typeof signature.r === 'undefined') return [];
  if (typeof signature.s === 'undefined') return [];
  if (typeof v === 'undefined' && typeof yParity === 'undefined') return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x';
    if (v === 0n) return '0x';
    if (v === 1n) return toHex(1);
    return v === 27n ? '0x' : toHex(1);
  })();
  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
}

const createBaseTransaction = tx => ({
  to: tx.to,
  data: tx.input,
  value: hexToBigInt(tx.value),
  gas: hexToBigInt(tx.gas),
  nonce: hexToNumber(tx.nonce),
  chainId: hexToNumber(tx.chainId)
});
const createEIP1559CompatibleTransaction = tx => ({
  ...createBaseTransaction(tx),
  type: "eip1559",
  maxFeePerGas: hexToBigInt(tx.maxFeePerGas),
  maxPriorityFeePerGas: hexToBigInt(tx.maxPriorityFeePerGas)
});
const createLegacyTransaction = tx => ({
  ...createBaseTransaction(tx),
  type: "legacy",
  gasPrice: hexToBigInt(tx.gasPrice)
});
const serializeTX = tx => {
  const serializableTx = isEIP1559CompatibleTransaction(tx.type) ? createEIP1559CompatibleTransaction(tx) : createLegacyTransaction(tx);
  return serializeTransaction(serializableTx);
};

export { serializeTX };
