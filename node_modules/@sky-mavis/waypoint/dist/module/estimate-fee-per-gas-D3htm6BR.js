import { HeadlessClientError, HeadlessClientErrorCode } from './headless/error/client.js';
import { request } from './headless/action/helpers/request/request.js';
import { isEIP1559CompatibleTransaction } from './headless/action/helpers/tx-type-check.js';
import { r as ronin, s as saigon } from './saigon-BY87pDOW.js';
import { h as hexToNumber, j as numberToHex, i as hexToBigInt } from './toBytes-CiKSrzpb.js';
import { f as formatGwei } from './formatGwei-BX_cgVog.js';
import { B as BaseError } from './base-CC-Hj7CW.js';

/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */
function getAction(client, actionFn,
// Some minifiers drop `Function.prototype.name`, or replace it with short letters,
// meaning that `actionFn.name` will not always work. For that case, the consumer
// needs to pass the name explicitly.
name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === 'function') return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === 'function') return action_explicit;
  return params => actionFn(client, params);
}

class BaseFeeScalarError extends BaseError {
  constructor() {
    super('`baseFeeMultiplier` must be greater than 1.', {
      name: 'BaseFeeScalarError'
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super('Chain does not support EIP-1559 fees.', {
      name: 'Eip1559FeesNotSupportedError'
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError {
  constructor({
    maxPriorityFeePerGas
  }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, {
      name: 'MaxFeePerGasTooLowError'
    });
  }
}

class BlockNotFoundError extends BaseError {
  constructor({
    blockHash,
    blockNumber
  }) {
    let identifier = 'Block';
    if (blockHash) identifier = `Block at hash "${blockHash}"`;
    if (blockNumber) identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, {
      name: 'BlockNotFoundError'
    });
  }
}

const transactionType = {
  '0x0': 'legacy',
  '0x1': 'eip2930',
  '0x2': 'eip1559',
  '0x3': 'eip4844',
  '0x4': 'eip7702'
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined
  };
  if (transaction.authorizationList) transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    // If `yParity` is provided, we will use it.
    if (transaction.yParity) return Number(transaction.yParity);
    // If no `yParity` provided, try derive from `v`.
    if (typeof transaction_.v === 'bigint') {
      if (transaction_.v === 0n || transaction_.v === 27n) return 0;
      if (transaction_.v === 1n || transaction_.v === 28n) return 1;
      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return undefined;
  })();
  if (transaction_.type === 'legacy') {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === 'eip2930') {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === 'eip1559') {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
//////////////////////////////////////////////////////////////////////////////
function formatAuthorizationList(authorizationList) {
  return authorizationList.map(authorization => ({
    contractAddress: authorization.address,
    r: authorization.r,
    s: authorization.s,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    ...(typeof authorization.yParity !== 'undefined' ? {
      yParity: Number(authorization.yParity)
    } : {}),
    ...(typeof authorization.v !== 'undefined' && typeof authorization.yParity === 'undefined' ? {
      v: Number(authorization.v)
    } : {})
  }));
}

function formatBlock(block) {
  const transactions = block.transactions?.map(transaction => {
    if (typeof transaction === 'string') return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}

/**
 * Returns information about a block at a block number, hash, or tag.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlock
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks
 * - JSON-RPC Methods:
 *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
 *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockParameters}
 * @returns Information about the block. {@link GetBlockReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlock } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const block = await getBlock(client)
 */
async function getBlock(client, {
  blockHash,
  blockNumber,
  blockTag: blockTag_,
  includeTransactions: includeTransactions_
} = {}) {
  const blockTag = blockTag_ ?? 'latest';
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: 'eth_getBlockByHash',
      params: [blockHash, includeTransactions]
    }, {
      dedupe: true
    });
  } else {
    block = await client.request({
      method: 'eth_getBlockByNumber',
      params: [blockNumberHex || blockTag, includeTransactions]
    }, {
      dedupe: Boolean(blockNumberHex)
    });
  }
  if (!block) throw new BlockNotFoundError({
    blockHash,
    blockNumber
  });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

/**
 * Returns the current price of gas (in wei).
 *
 * - Docs: https://viem.sh/docs/actions/public/getGasPrice
 * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
 *
 * @param client - Client to use
 * @returns The gas price (in wei). {@link GetGasPriceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getGasPrice } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasPrice = await getGasPrice(client)
 */
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: 'eth_gasPrice'
  });
  return BigInt(gasPrice);
}

async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const {
    block: block_,
    chain = client.chain,
    request
  } = args || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === 'function') {
      const block = block_ || (await getAction(client, getBlock, 'getBlock')({}));
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null) throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== 'undefined') return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: 'eth_maxPriorityFeePerGas'
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    // If the RPC Provider does not support `eth_maxPriorityFeePerGas`
    // fall back to calculating it manually via `gasPrice - baseFeePerGas`.
    // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee
    const [block, gasPrice] = await Promise.all([block_ ? Promise.resolve(block_) : getAction(client, getBlock, 'getBlock')({}), getAction(client, getGasPrice, 'getGasPrice')({})]);
    if (typeof block.baseFeePerGas !== 'bigint') throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n) return 0n;
    return maxPriorityFeePerGas;
  }
}

/**
 * Returns an estimate for the fees per gas (in wei) for a
 * transaction to be likely included in the next block.
 * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateFeesPerGasParameters}
 * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateFeesPerGas } from 'viem/actions'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const maxPriorityFeePerGas = await estimateFeesPerGas(client)
 * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }
 */
async function estimateFeesPerGas$1(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const {
    block: block_,
    chain = client.chain,
    request,
    type = 'eip1559'
  } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === 'function') return chain.fees.baseFeeMultiplier({
      block: block_,
      client,
      request
    });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1) throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = base => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, 'getBlock')({});
  if (typeof chain?.fees?.estimateFeesPerGas === 'function') {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null) return fees;
  }
  if (type === 'eip1559') {
    if (typeof block.baseFeePerGas !== 'bigint') throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === 'bigint' ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block: block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, 'getGasPrice')({}));
  return {
    gasPrice
  };
}

const GAS_SUGGESTION_ROUTES = {
  [ronin.id]: "get https://wallet-manager.skymavis.com/proxy/public/v1/ronin/gas-suggestion",
  [saigon.id]: "get https://wallet-manager-stg.skymavis.one/proxy/public/v1/ronin-testnet/gas-suggestion"
};
const GAS_PRICE_BUFFER_PERCENTAGE = 2; // 2%
const applyBuffer = (value, percentage) => value * BigInt(100 + percentage) / 100n;
const fetchEIP1559GasSuggestion = async (client, chainId) => {
  const route = GAS_SUGGESTION_ROUTES[chainId];
  if (!route) throw new HeadlessClientError({
    cause: undefined,
    code: HeadlessClientErrorCode.PrepareTransactionError,
    message: `Unsupported chain: ${chainId}.`
  });
  try {
    const {
      data
    } = await request(route);
    if (!data) throw new HeadlessClientError({
      cause: undefined,
      code: HeadlessClientErrorCode.PrepareTransactionError,
      message: "Empty gas suggestion response."
    });
    return {
      maxFeePerGas: data.medium.max_fee_per_gas,
      maxPriorityFeePerGas: data.medium.max_priority_fee_per_gas
    };
  } catch (error) {
    return await estimateFeesPerGas$1(client);
  }
};
const handleEIP1559Transaction = async (client, params) => {
  const {
    chainId,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = params;
  if (maxFeePerGas && maxPriorityFeePerGas) {
    return {
      gasPrice: "0x0",
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasSuggestion = await fetchEIP1559GasSuggestion(client, chainId);
  return {
    gasPrice: "0x0",
    maxPriorityFeePerGas: maxPriorityFeePerGas || numberToHex(gasSuggestion.maxPriorityFeePerGas),
    maxFeePerGas: maxFeePerGas || numberToHex(gasSuggestion.maxFeePerGas)
  };
};
const handleLegacyTransaction = async (client, gasPrice) => {
  if (gasPrice) {
    return {
      gasPrice,
      maxPriorityFeePerGas: "0x0",
      maxFeePerGas: "0x0"
    };
  }
  const baseGasPrice = await getGasPrice(client);
  const bufferedGasPrice = applyBuffer(baseGasPrice, GAS_PRICE_BUFFER_PERCENTAGE);
  return {
    gasPrice: numberToHex(bufferedGasPrice),
    maxPriorityFeePerGas: "0x0",
    maxFeePerGas: "0x0"
  };
};
async function estimateFeesPerGas(client, params) {
  const {
    type,
    gasPrice
  } = params;
  try {
    if (isEIP1559CompatibleTransaction(type)) return await handleEIP1559Transaction(client, params);
    return await handleLegacyTransaction(client, gasPrice);
  } catch (error) {
    throw new HeadlessClientError({
      cause: error,
      code: HeadlessClientErrorCode.PrepareTransactionError,
      message: "Failed to estimate gas price. This could be due to network issues or RPC problems."
    });
  }
}

export { Eip1559FeesNotSupportedError as E, GAS_SUGGESTION_ROUTES as G, MaxFeePerGasTooLowError as M, getBlock as a, GAS_PRICE_BUFFER_PERCENTAGE as b, applyBuffer as c, estimateFeesPerGas as e, getAction as g, internal_estimateFeesPerGas as i };
